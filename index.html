<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Neon Oracle :: Modern Linux Terminal</title>

    <!-- Meta Description -->
    <meta name="description" content="Modern Neon Oracle - A stylish, terminal-themed web application with games, quotes, and retro computing vibes.">

    <!-- Favicon Links -->
    <link rel="apple-touch-icon" sizes="180x180" href="favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon/favicon-16x16.png">
    <link rel="manifest" href="favicon/webmanifest.json">
    <link rel="shortcut icon" href="favicon/favicon.ico">

    <!-- Open Graph Meta Tags (for social sharing) -->
    <meta property="og:title" content="Neon Oracle :: Linux Terminal">
    <meta property="og:description" content="Neon Oracle is a stylish, terminal-themed web application that generates and displays inspirational quotes in a nostalgic command-line interface.">
    <meta property="og:image" content="https://i.ibb.co/9kLdSDzp/neonoracle.jpg">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://saganaki22.github.io/NeonOracle/">

    <!-- Twitter Card (for better previews on Twitter) -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Neon Oracle :: Linux Terminal">
    <meta name="twitter:description" content="Neon Oracle is a stylish, terminal-themed web application that generates and displays inspirational quotes in a nostalgic command-line interface.">
    <meta name="twitter:image" content="https://i.ibb.co/9kLdSDzp/neonoracle.jpg">

    <!-- PWA Manifest -->
    <link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiTmVvbiBPcmFjbGUiLCJzaG9ydF9uYW1lIjoiTmVvbk9yYWNsZSIsImRlc2NyaXB0aW9uIjoiTW9kZXJuIHRlcm1pbmFsIGludGVyZmFjZSIsInN0YXJ0X3VybCI6Ii8iLCJkaXNwbGF5Ijoic3RhbmRhbG9uZSIsInRoZW1lX2NvbG9yIjoiIzAwMDAwMCIsImJhY2tncm91bmRfY29sb3IiOiIjMDAwMDAwIn0=">

    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300;400;500;600;700&family=JetBrains+Mono:wght@100;200;300;400;500;600;700;800&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/@phosphor-icons/web"></script>

    <style>
        /* Modern CSS Custom Properties */
        :root {
            --terminal-primary: #00ff41;
            --terminal-secondary: #008f11;
            --terminal-accent: #ff0080;
            --terminal-warning: #ffaa00;
            --terminal-error: #ff3030;
            --terminal-white: #ffffff;
            --terminal-gray: #aaaaaa;
            --terminal-dark-gray: #666666;
            --terminal-bg: #000000;
            --terminal-header: #1a1a1a;
            --terminal-content-bg: rgba(0, 0, 0, 0.95);
            --terminal-border: rgba(0, 255, 65, 0.3);
            --terminal-shadow: rgba(0, 255, 65, 0.2);
            --terminal-glow: rgba(0, 255, 65, 0.4);
            
            /* Control colors */
            --control-red: #ff5f56;
            --control-yellow: #ffbd2e;
            --control-green: #27ca42;
            
            /* Responsive spacing */
            --spacing-xs: 0.25rem;
            --spacing-sm: 0.5rem;
            --spacing-md: 1rem;
            --spacing-lg: 1.5rem;
            --spacing-xl: 2rem;
            --spacing-xxl: 3rem;
            
            /* Typography */
            --font-family-mono: 'Fira Code', 'JetBrains Mono', 'Consolas', monospace;
            --font-size-xs: 0.75rem;
            --font-size-sm: 0.875rem;
            --font-size-base: 1rem;
            --font-size-lg: 1.125rem;
            --font-size-xl: 1.25rem;
            --font-size-xxl: 1.5rem;
            
            /* Animations */
            --animation-speed: 0.3s;
            --animation-curve: cubic-bezier(0.4, 0, 0.2, 1);
            
            /* Z-indexes */
            --z-background: -1;
            --z-scanlines: 1;
            --z-terminal: 100;
            --z-active-terminal: 200;
            --z-modal: 1000;
            --z-game: 1001;
        }

        /* CSS Reset & Base Styles */
        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            font-size: 16px;
            scroll-behavior: smooth;
        }

        body {
            font-family: var(--font-family-mono);
            font-weight: 400;
            line-height: 1.5;
            color: var(--terminal-primary);
            background: var(--terminal-bg);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            position: fixed;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            touch-action: manipulation;
        }

        /* Utility Classes */
        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        .no-select {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* Background Effects */
        .bg-project-name {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(2rem, 8vw, 6rem);
            font-weight: 700;
            color: rgba(0, 255, 65, 0.03);
            white-space: nowrap;
            z-index: var(--z-background);
            font-family: var(--font-family-mono);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            transition: color var(--animation-speed) var(--animation-curve);
            cursor: pointer;
            pointer-events: auto;
        }

        .bg-project-name:hover {
            color: rgba(0, 255, 65, 0.08);
        }

        .bg-project-name.bright {
            color: rgba(0, 255, 65, 0.15);
        }

        /* Matrix Rain Background Effect */
        .matrix-rain {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: var(--z-background);
            opacity: 0.1;
            pointer-events: none;
        }

        .matrix-rain canvas {
            display: block;
        }

        /* Scanlines Effect */
        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                transparent 50%,
                rgba(0, 255, 65, 0.03) 50%
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: var(--z-scanlines);
            animation: scanlines 0.1s linear infinite;
        }

        @keyframes scanlines {
            0% { transform: translateY(0); }
            100% { transform: translateY(4px); }
        }

        /* Terminal Container */
        .terminal-container {
            position: absolute;
            min-width: min(90vw, 600px);
            min-height: min(70vh, 400px);
            background: var(--terminal-content-bg);
            border: 1px solid var(--terminal-border);
            border-radius: 12px;
            box-shadow: 
                0 0 0 1px rgba(0, 255, 65, 0.1),
                0 10px 30px var(--terminal-shadow),
                0 0 60px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            z-index: var(--z-terminal);
            transition: all var(--animation-speed) var(--animation-curve);
            will-change: transform;
            contain: layout style paint;
            user-select: none;
        }

        .terminal-container.active {
            z-index: var(--z-active-terminal);
            box-shadow: 
                0 0 0 1px var(--terminal-primary),
                0 15px 60px var(--terminal-glow),
                0 0 100px rgba(0, 0, 0, 0.7);
        }

        .terminal-container.maximized {
            width: 100vw !important;
            height: 100vh !important;
            border-radius: 0 !important;
            top: 0 !important;
            left: 0 !important;
            transform: none !important;
        }

        .terminal-container.minimized {
            transform: scale(0.1);
            opacity: 0;
            pointer-events: none;
        }

        .terminal-container.closing {
            animation: closeTerminal var(--animation-speed) var(--animation-curve) forwards;
        }

        .terminal-container.dragging {
            transition: none !important;
            cursor: grabbing !important;
            transform: scale(1.02);
            box-shadow: 
                0 0 0 1px var(--terminal-primary),
                0 20px 60px var(--terminal-glow),
                0 0 120px rgba(0, 0, 0, 0.8);
        }

        @keyframes closeTerminal {
            to {
                transform: scale(0.8);
                opacity: 0;
            }
        }

        /* Terminal Header */
        .terminal-header {
            background: var(--terminal-header);
            padding: var(--spacing-sm) var(--spacing-md);
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid var(--terminal-border);
            cursor: grab;
            user-select: none;
            min-height: 48px;
        }

        .terminal-header:active {
            cursor: grabbing;
        }

        .terminal-title {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            color: var(--terminal-white);
            font-size: var(--font-size-sm);
            font-weight: 500;
        }

        .terminal-controls {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .control-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            cursor: pointer;
            transition: all var(--animation-speed) var(--animation-curve);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .control-dot::before {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: currentColor;
            opacity: 0;
            transform: scale(0);
            transition: all var(--animation-speed) var(--animation-curve);
        }

        .control-dot:hover::before {
            opacity: 0.2;
            transform: scale(1);
        }

        .control-dot i {
            font-size: 8px;
            color: rgba(0, 0, 0, 0.8);
            opacity: 0;
            transition: opacity var(--animation-speed) var(--animation-curve);
        }

        .control-dot:hover i {
            opacity: 1;
        }

        .red-dot { background: var(--control-red); }
        .yellow-dot { background: var(--control-yellow); }
        .green-dot { background: var(--control-green); }

        /* Terminal Content */
        .terminal-content {
            flex: 1;
            overflow-y: auto;
            padding: var(--spacing-md);
            background: var(--terminal-bg);
            font-family: var(--font-family-mono);
            font-size: var(--font-size-sm);
            line-height: 1.6;
            scrollbar-width: thin;
            scrollbar-color: var(--terminal-primary) transparent;
            user-select: text;
        }

        .terminal-content::-webkit-scrollbar {
            width: 8px;
        }

        .terminal-content::-webkit-scrollbar-track {
            background: transparent;
        }

        .terminal-content::-webkit-scrollbar-thumb {
            background: var(--terminal-primary);
            border-radius: 4px;
            opacity: 0.6;
        }

        .terminal-content::-webkit-scrollbar-thumb:hover {
            opacity: 1;
        }

        /* Terminal Text Elements */
        .command-line {
            display: flex;
            margin-bottom: var(--spacing-sm);
            animation: fadeIn 0.3s ease-out;
        }

        .prompt {
            color: var(--terminal-primary);
            margin-right: var(--spacing-sm);
            white-space: nowrap;
            font-weight: 600;
        }

        .command {
            color: var(--terminal-white);
            flex: 1;
        }

        .response {
            color: var(--terminal-primary);
            margin-bottom: var(--spacing-md);
            white-space: pre-wrap;
            word-wrap: break-word;
            animation: fadeIn 0.3s ease-out;
        }

        .error {
            color: var(--terminal-error);
        }

        .warning {
            color: var(--terminal-warning);
        }

        .success {
            color: var(--terminal-primary);
        }

        .info {
            color: var(--terminal-accent);
        }

        /* Progress Bar */
        .progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(0, 255, 65, 0.1);
            border: 1px solid var(--terminal-primary);
            border-radius: 4px;
            overflow: hidden;
            margin: var(--spacing-sm) 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--terminal-primary), var(--terminal-accent));
            width: 0%;
            transition: width 0.1s ease-out;
            border-radius: 3px;
        }

        /* ASCII Art */
        .ascii-art {
            color: var(--terminal-primary);
            font-family: var(--font-family-mono);
            font-size: var(--font-size-xs);
            line-height: 1.2;
            margin: var(--spacing-lg) 0;
            white-space: pre;
            animation: glitch 2s infinite;
        }

        @keyframes glitch {
            0%, 100% { transform: translate(0); }
            20% { transform: translate(-1px, 1px); }
            40% { transform: translate(-1px, -1px); }
            60% { transform: translate(1px, 1px); }
            80% { transform: translate(1px, -1px); }
        }

        /* Quote Section */
        .quote-section {
            border: 1px solid var(--terminal-border);
            border-radius: 8px;
            padding: var(--spacing-lg);
            margin: var(--spacing-lg) 0;
            background: rgba(0, 255, 65, 0.03);
            backdrop-filter: blur(5px);
            animation: fadeInUp 0.5s ease-out;
        }

        .quote-text {
            color: var(--terminal-white);
            font-size: var(--font-size-lg);
            font-weight: 500;
            margin-bottom: var(--spacing-md);
            line-height: 1.4;
        }

        .quote-author {
            color: var(--terminal-gray);
            text-align: right;
            font-style: italic;
            font-size: var(--font-size-sm);
        }

        /* Buttons */
        .terminal-button {
            background: transparent;
            color: var(--terminal-primary);
            border: 1px solid var(--terminal-primary);
            border-radius: 6px;
            padding: var(--spacing-sm) var(--spacing-md);
            font-family: var(--font-family-mono);
            font-size: var(--font-size-sm);
            cursor: pointer;
            transition: all var(--animation-speed) var(--animation-curve);
            display: inline-flex;
            align-items: center;
            gap: var(--spacing-sm);
            text-decoration: none;
        }

        .terminal-button:hover {
            background: rgba(0, 255, 65, 0.1);
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.3);
            transform: translateY(-2px);
        }

        .terminal-button:active {
            transform: translateY(0);
        }

        .share-container {
            display: flex;
            gap: var(--spacing-sm);
            margin-top: var(--spacing-md);
            flex-wrap: wrap;
        }

        /* Terminal Input */
        .terminal-input-wrapper {
            display: flex;
            align-items: center;
            border-top: 1px solid var(--terminal-border);
            padding: var(--spacing-md);
            background: rgba(0, 255, 65, 0.02);
            min-height: 60px;
        }

        .terminal-input-prompt {
            color: var(--terminal-primary);
            margin-right: var(--spacing-sm);
            white-space: nowrap;
            font-weight: 600;
        }

        .terminal-input {
            flex: 1;
            background: transparent;
            border: none;
            color: var(--terminal-white);
            font-family: var(--font-family-mono);
            font-size: var(--font-size-base);
            outline: none;
            caret-color: var(--terminal-primary);
        }

        .terminal-input::placeholder {
            color: var(--terminal-dark-gray);
        }

        /* Floating Action Button */
        .floating-actions {
            position: fixed;
            bottom: var(--spacing-xl);
            right: var(--spacing-xl);
            display: flex;
            flex-direction: column;
            gap: var(--spacing-md);
            z-index: 500;
        }

        .fab {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: var(--terminal-content-bg);
            color: var(--terminal-primary);
            border: 2px solid var(--terminal-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all var(--animation-speed) var(--animation-curve);
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px var(--terminal-shadow);
        }

        .fab:hover {
            transform: scale(1.1);
            box-shadow: 0 8px 30px var(--terminal-glow);
        }

        .fab i {
            font-size: 24px;
        }

        /* Game Canvas */
        .game-canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--terminal-bg);
            border: 2px solid var(--terminal-primary);
            border-radius: 8px;
            z-index: var(--z-game);
            box-shadow: 0 0 50px var(--terminal-glow);
            display: block;
        }

        .game-canvas.active {
            display: block;
            animation: fadeInScale 0.3s ease-out;
        }

        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        /* Game Overlay */
        .game-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: var(--z-game);
            display: none;
            align-items: center;
            justify-content: center;
        }

        .game-overlay.active {
            display: flex;
        }

        /* Typing Animation */
        .typing-animation {
            overflow: hidden;
            white-space: nowrap;
            animation: typing 2s steps(40, end);
        }

        @keyframes typing {
            from { width: 0; }
            to { width: 100%; }
        }

        .cursor {
            display: inline-block;
            background: var(--terminal-primary);
            width: 2px;
            height: 1em;
            animation: blink 1s infinite;
            margin-left: 2px;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        /* Loading Animation */
        .loading-dots {
            display: inline-flex;
            gap: 2px;
        }

        .loading-dots span {
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background: var(--terminal-primary);
            animation: loadingDots 1.4s infinite ease-in-out both;
        }

        .loading-dots span:nth-child(1) { animation-delay: -0.32s; }
        .loading-dots span:nth-child(2) { animation-delay: -0.16s; }

        @keyframes loadingDots {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1); }
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Resize handles for desktop */
        .resize-handle {
            position: absolute;
            background: transparent;
            z-index: 1000;
            transition: background-color 0.2s ease;
        }

        .resize-handle:hover {
            background: rgba(0, 255, 65, 0.1);
        }

        .resize-handle-n, .resize-handle-s {
            height: 6px;
            left: 6px;
            right: 6px;
        }

        .resize-handle-e, .resize-handle-w {
            width: 6px;
            top: 6px;
            bottom: 6px;
        }

        .resize-handle-n { top: -3px; cursor: n-resize; }
        .resize-handle-s { bottom: -3px; cursor: s-resize; }
        .resize-handle-e { right: -3px; cursor: e-resize; }
        .resize-handle-w { left: -3px; cursor: w-resize; }

        .resize-handle-ne, .resize-handle-nw,
        .resize-handle-se, .resize-handle-sw {
            width: 12px;
            height: 12px;
        }

        .resize-handle-ne { top: -6px; right: -6px; cursor: ne-resize; }
        .resize-handle-nw { top: -6px; left: -6px; cursor: nw-resize; }
        .resize-handle-se { bottom: -6px; right: -6px; cursor: se-resize; }
        .resize-handle-sw { bottom: -6px; left: -6px; cursor: sw-resize; }

        /* Responsive Design */
        @media (max-width: 768px) {
            :root {
                --font-size-base: 0.9rem;
                --font-size-sm: 0.8rem;
                --spacing-md: 0.75rem;
            }

            .terminal-container {
                width: 100vw !important;
                height: 100vh !important;
                min-width: 100vw !important;
                min-height: 100vh !important;
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                border-radius: 0 !important;
                transform: none !important;
            }

            .terminal-header {
                padding: var(--spacing-md);
                min-height: 56px;
            }

            .control-dot {
                width: 18px;
                height: 18px;
            }

            .floating-actions {
                bottom: var(--spacing-lg);
                right: var(--spacing-lg);
            }

            .fab {
                width: 48px;
                height: 48px;
            }

            .fab i {
                font-size: 20px;
            }

            .bg-project-name {
                font-size: clamp(1.5rem, 12vw, 4rem);
            }

            .resize-handle {
                display: none;
            }
        }

        /* Dark mode support */
        @media (prefers-color-scheme: dark) {
            :root {
                --terminal-primary: #00ff41;
                --terminal-bg: #000000;
            }
        }

        /* Reduced motion */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* High contrast mode */
        @media (prefers-contrast: high) {
            :root {
                --terminal-primary: #ffffff;
                --terminal-border: #ffffff;
            }
        }

        /* Performance optimizations */
        .terminal-container {
            transform-style: preserve-3d;
            will-change: transform;
        }

        .terminal-content {
            contain: layout style paint;
            content-visibility: auto;
        }
    </style>
</head>
<body>
    <!-- Matrix Rain Background -->
    <div class="matrix-rain">
        <canvas id="matrixCanvas"></canvas>
    </div>

    <!-- Scanlines Effect -->
    <div class="scanlines"></div>
    
    <!-- Background Project Name -->
    <div class="bg-project-name no-select" id="bgProjectName">NEON ORACLE v3.0</div>
    
    <!-- Floating Action Buttons -->
    <div class="floating-actions">
        <button class="fab" id="newTerminalBtn" title="New Terminal" aria-label="Create new terminal">
            <i class="ph ph-terminal"></i>
        </button>
        <button class="fab" id="gameMenuBtn" title="Games" aria-label="Open games menu">
            <i class="ph ph-game-controller"></i>
        </button>
    </div>

    <!-- Game Overlay -->
    <div class="game-overlay" id="gameOverlay">
        <canvas class="game-canvas" id="gameCanvas" width="400" height="400"></canvas>
    </div>
    
    <!-- Terminal Template -->
    <template id="terminalTemplate">
        <div class="terminal-container">
            <div class="terminal-header">
                <div class="terminal-title">
                    <i class="ph ph-terminal"></i>
                    <span class="terminal-path">user@neon-oracle: ~/</span>
                </div>
                <div class="terminal-controls">
                    <div class="control-dot red-dot" title="Close" aria-label="Close terminal">
                        <i class="ph ph-x"></i>
                    </div>
                    <div class="control-dot yellow-dot" title="Minimize" aria-label="Minimize terminal">
                        <i class="ph ph-minus"></i>
                    </div>
                    <div class="control-dot green-dot" title="Maximize" aria-label="Maximize terminal">
                        <i class="ph ph-square"></i>
                    </div>
                </div>
            </div>
            
            <div class="terminal-content"></div>
            
            <div class="terminal-input-wrapper">
                <div class="terminal-input-prompt">user@neon-oracle:~$</div>
                <input type="text" class="terminal-input" placeholder="Type 'help' for commands" autocomplete="off" spellcheck="false">
            </div>
            
            <!-- Resize handles (desktop only) -->
            <div class="resize-handle resize-handle-n"></div>
            <div class="resize-handle resize-handle-e"></div>
            <div class="resize-handle resize-handle-s"></div>
            <div class="resize-handle resize-handle-w"></div>
            <div class="resize-handle resize-handle-ne"></div>
            <div class="resize-handle resize-handle-se"></div>
            <div class="resize-handle resize-handle-sw"></div>
            <div class="resize-handle resize-handle-nw"></div>
        </div>
    </template>
    
    <script>
        // Modern JavaScript with ES6+ features
        class NeonOracle {
            constructor() {
                this.terminals = new Map();
                this.activeTerminal = null;
                this.zIndexCounter = 100;
                this.gameInstance = null;
                this.quotes = null;
                this.matrixRain = null;
                this.isDragging = false;
                this.isResizing = false;
                
                this.init();
            }

            async init() {
                console.log('%cðŸš€ NEON ORACLE v3.0 INITIALIZED', 'color: #00ff41; font-size: 16px; font-weight: bold;');
                
                // Initialize matrix rain effect
                this.initMatrixRain();
                
                // Load quotes from GitHub
                await this.loadQuotes();
                
                // Setup event listeners
                this.setupEventListeners();
                
                // Create initial terminal
                this.createTerminal();
                
                // Register service worker for PWA
                this.registerServiceWorker();
            }

            // Matrix Rain Effect - FIXED SPEED
            initMatrixRain() {
                const canvas = document.getElementById('matrixCanvas');
                const ctx = canvas.getContext('2d');
                let animationId;
                let lastFrameTime = 0;
                const frameDelay = 33; // 30fps - perfect speed
                
                const resizeCanvas = () => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                    this.setupMatrixDrops();
                };
                
                this.setupMatrixDrops = () => {
                    const fontSize = 14;
                    const columns = Math.floor(canvas.width / fontSize);
                    this.matrixDrops = [];
                    
                    for (let x = 0; x < columns; x++) {
                        this.matrixDrops[x] = Math.random() * canvas.height / fontSize;
                    }
                };
                
                resizeCanvas();
                
                // Simple resize handler
                window.addEventListener('resize', () => {
                    requestAnimationFrame(resizeCanvas);
                });
                
                const chars = 'ã‚¢ã‚¡ã‚«ã‚µã‚¿ãƒŠãƒãƒžãƒ¤ãƒ£ãƒ©ãƒ¯ã‚¬ã‚¶ãƒ€ãƒãƒ‘ã‚¤ã‚£ã‚­ã‚·ãƒãƒ‹ãƒ’ãƒŸãƒªãƒ°ã‚®ã‚¸ãƒ‚ãƒ“ãƒ”ã‚¦ã‚¥ã‚¯ã‚¹ãƒ„ãƒŒãƒ•ãƒ ãƒ¦ãƒ¥ãƒ«ã‚°ã‚ºãƒ…ãƒ–ãƒ—ã‚¨ã‚§ã‚±ã‚»ãƒ†ãƒãƒ˜ãƒ¡ãƒ¬ãƒ±ã‚²ã‚¼ãƒ‡ãƒ™ãƒšã‚ªã‚©ã‚³ã‚½ãƒˆãƒŽãƒ›ãƒ¢ãƒ¨ãƒ§ãƒ­ãƒ²ã‚´ã‚¾ãƒ‰ãƒœãƒãƒ´ãƒƒãƒ³0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                const charArray = chars.split('');
                const fontSize = 14;
                
                const draw = (currentTime) => {
                    if (currentTime - lastFrameTime < frameDelay) {
                        animationId = requestAnimationFrame(draw);
                        return;
                    }
                    
                    lastFrameTime = currentTime;
                    
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.fillStyle = '#00ff41';
                    ctx.font = fontSize + 'px Fira Code';
                    
                    if (this.matrixDrops) {
                        for (let i = 0; i < this.matrixDrops.length; i++) {
                            const text = charArray[Math.floor(Math.random() * charArray.length)];
                            ctx.fillText(text, i * fontSize, this.matrixDrops[i] * fontSize);
                            
                            if (this.matrixDrops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                                this.matrixDrops[i] = 0;
                            }
                            this.matrixDrops[i]++;
                        }
                    }
                    
                    animationId = requestAnimationFrame(draw);
                };
                
                draw(0);
                this.matrixAnimationId = animationId;
            }

            // Load quotes from GitHub
            async loadQuotes() {
                try {
                    console.log('Fetching quotes from GitHub...');
                    const response = await fetch('https://raw.githubusercontent.com/Saganaki22/NeonOracle/refs/heads/main/quotes.json');
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    this.quotes = await response.json();
                    console.log('âœ… Quotes loaded successfully from GitHub!', this.quotes);
                    return true;
                } catch (error) {
                    console.error('âŒ Failed to load quotes from GitHub:', error);
                    
                    // Fallback quotes
                    this.quotes = {
                        categories: {
                            "Inspiration": [
                                { text: "The future belongs to those who believe in the beauty of their dreams.", author: "Eleanor Roosevelt" },
                                { text: "Code is poetry written in logic.", author: "Anonymous" },
                                { text: "In the world of algorithms, elegance is efficiency.", author: "Modern Oracle" }
                            ],
                            "Technology": [
                                { text: "Any sufficiently advanced technology is indistinguishable from magic.", author: "Arthur C. Clarke" },
                                { text: "The best way to predict the future is to create it.", author: "Peter Drucker" },
                                { text: "Programs must be written for people to read, and only incidentally for machines to execute.", author: "Harold Abelson" }
                            ],
                            "Philosophy": [
                                { text: "The only way to make sense out of change is to plunge into it, move with it, and join the dance.", author: "Alan Watts" },
                                { text: "We are what we repeatedly do. Excellence, then, is not an act, but a habit.", author: "Aristotle" },
                                { text: "The cave you fear to enter holds the treasure you seek.", author: "Joseph Campbell" }
                            ]
                        }
                    };
                    return false;
                }
            }

            // Get random quote
            getRandomQuote() {
                if (!this.quotes) return null;
                
                const categories = Object.keys(this.quotes.categories);
                const randomCategory = categories[Math.floor(Math.random() * categories.length)];
                const quotes = this.quotes.categories[randomCategory];
                
                return quotes[Math.floor(Math.random() * quotes.length)];
            }

            // Setup event listeners
            setupEventListeners() {
                const newTerminalBtn = document.getElementById('newTerminalBtn');
                const gameMenuBtn = document.getElementById('gameMenuBtn');
                const bgProjectName = document.getElementById('bgProjectName');
                const gameOverlay = document.getElementById('gameOverlay');
                
                newTerminalBtn.addEventListener('click', () => this.createTerminal());
                gameMenuBtn.addEventListener('click', () => this.showGameMenu());
                
                // Background click handler
                bgProjectName.addEventListener('click', (e) => {
                    if (!this.isOverTerminal(e)) {
                        window.open('https://github.com/saganaki22/neonoracle', '_blank');
                    }
                });

                // Close game overlay when clicked outside
                gameOverlay.addEventListener('click', (e) => {
                    if (e.target === gameOverlay) {
                        this.closeGame();
                    }
                });

                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        switch (e.key) {
                            case 't':
                                e.preventDefault();
                                this.createTerminal();
                                break;
                            case 'w':
                                e.preventDefault();
                                if (this.activeTerminal) {
                                    this.closeTerminal(this.activeTerminal);
                                }
                                break;
                        }
                    }
                    
                    // Close game on escape
                    if (e.key === 'Escape' && this.gameInstance) {
                        this.closeGame();
                    }
                });

                // Simple resize handler
                window.addEventListener('resize', () => {
                    this.handleResize();
                });
            }

            // Utility: Simple debounce function
            debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }

            // Check if mouse is over terminal
            isOverTerminal(event) {
                const terminals = document.querySelectorAll('.terminal-container');
                for (const terminal of terminals) {
                    const rect = terminal.getBoundingClientRect();
                    if (event.clientX >= rect.left && event.clientX <= rect.right &&
                        event.clientY >= rect.top && event.clientY <= rect.bottom) {
                        return true;
                    }
                }
                return false;
            }

            // Handle window resize - SIMPLIFIED
            handleResize() {
                const isMobile = window.innerWidth <= 768;
                
                this.terminals.forEach(terminal => {
                    if (isMobile) {
                        terminal.style.width = '100vw';
                        terminal.style.height = '100vh';
                        terminal.style.top = '0';
                        terminal.style.left = '0';
                    }
                });
            }

            // Create terminal
            createTerminal() {
                const template = document.getElementById('terminalTemplate');
                const terminalElement = template.content.cloneNode(true).querySelector('.terminal-container');
                const terminalId = `terminal-${Date.now()}`;
                
                terminalElement.id = terminalId;
                
                // Position terminal
                const isMobile = window.innerWidth <= 768;
                if (!isMobile) {
                    const offset = this.terminals.size * 30;
                    terminalElement.style.left = `${Math.min(offset + 50, window.innerWidth - 650)}px`;
                    terminalElement.style.top = `${Math.min(offset + 50, window.innerHeight - 450)}px`;
                    terminalElement.style.width = '60vw';
                    terminalElement.style.height = '70vh';
                }
                
                document.body.appendChild(terminalElement);
                
                // Store terminal reference
                this.terminals.set(terminalId, terminalElement);
                
                // Setup terminal
                this.setupTerminalControls(terminalElement);
                this.setupTerminalDrag(terminalElement);
                this.setupTerminalResize(terminalElement);
                this.setupTerminalInput(terminalElement);
                this.setActiveTerminal(terminalElement);
                
                // Initialize terminal content
                this.initTerminalContent(terminalElement);
                
                return terminalElement;
            }

            // Setup terminal controls
            setupTerminalControls(terminal) {
                const controls = terminal.querySelector('.terminal-controls');
                const redDot = controls.querySelector('.red-dot');
                const yellowDot = controls.querySelector('.yellow-dot');
                const greenDot = controls.querySelector('.green-dot');
                
                redDot.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.closeTerminal(terminal);
                });
                
                yellowDot.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.minimizeTerminal(terminal);
                });
                
                greenDot.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.toggleMaximizeTerminal(terminal);
                });
                
                // Click to focus
                terminal.addEventListener('click', () => {
                    this.setActiveTerminal(terminal);
                });
            }

            // Close terminal
            closeTerminal(terminal) {
                terminal.classList.add('closing');
                
                // Clean up drag events
                if (terminal._dragCleanup) {
                    terminal._dragCleanup();
                }
                
                setTimeout(() => {
                    terminal.remove();
                    this.terminals.delete(terminal.id);
                    
                    // Set focus to another terminal if available
                    if (this.activeTerminal === terminal) {
                        const remainingTerminals = Array.from(this.terminals.values());
                        if (remainingTerminals.length > 0) {
                            this.setActiveTerminal(remainingTerminals[0]);
                        } else {
                            this.activeTerminal = null;
                        }
                    }
                }, 300);
            }

            // Minimize terminal
            minimizeTerminal(terminal) {
                terminal.classList.add('minimized');
                setTimeout(() => {
                    terminal.style.display = 'none';
                    terminal.classList.remove('minimized');
                }, 300);
            }

            // Toggle maximize terminal
            toggleMaximizeTerminal(terminal) {
                const isMaximized = terminal.classList.contains('maximized');
                const greenDot = terminal.querySelector('.green-dot i');
                
                if (isMaximized) {
                    terminal.classList.remove('maximized');
                    greenDot.className = 'ph ph-square';
                } else {
                    terminal.classList.add('maximized');
                    greenDot.className = 'ph ph-corners-out';
                }
            }

            // Set active terminal
            setActiveTerminal(terminal) {
                // Remove active class from all terminals
                this.terminals.forEach(t => t.classList.remove('active'));
                
                // Set active
                terminal.classList.add('active');
                this.activeTerminal = terminal;
                
                // Bring to front
                terminal.style.zIndex = ++this.zIndexCounter;
                
                // Focus input
                const input = terminal.querySelector('.terminal-input');
                input?.focus();
            }

            // Setup terminal drag (desktop only) - FIXED DRAGGING
            setupTerminalDrag(terminal) {
                if (window.innerWidth <= 768) return;
                
                const header = terminal.querySelector('.terminal-header');
                let isDragging = false;
                let dragData = null;
                
                const onMouseDown = (e) => {
                    if (e.target.closest('.terminal-controls')) return;
                    if (isDragging) return; // Prevent multiple drags
                    
                    isDragging = true;
                    this.isDragging = true;
                    
                    dragData = {
                        startX: e.clientX,
                        startY: e.clientY,
                        startLeft: terminal.offsetLeft,
                        startTop: terminal.offsetTop,
                        terminal: terminal
                    };
                    
                    terminal.classList.add('dragging');
                    this.setActiveTerminal(terminal);
                    
                    e.preventDefault();
                    e.stopPropagation();
                };
                
                const onMouseMove = (e) => {
                    if (!isDragging || !dragData || dragData.terminal !== terminal) return;
                    
                    const deltaX = e.clientX - dragData.startX;
                    const deltaY = e.clientY - dragData.startY;
                    
                    const newLeft = Math.max(0, Math.min(window.innerWidth - terminal.offsetWidth, dragData.startLeft + deltaX));
                    const newTop = Math.max(0, Math.min(window.innerHeight - terminal.offsetHeight, dragData.startTop + deltaY));
                    
                    terminal.style.left = `${newLeft}px`;
                    terminal.style.top = `${newTop}px`;
                    
                    e.preventDefault();
                    e.stopPropagation();
                };
                
                const onMouseUp = (e) => {
                    if (!isDragging) return;
                    
                    isDragging = false;
                    this.isDragging = false;
                    dragData = null;
                    terminal.classList.remove('dragging');
                    
                    e.preventDefault();
                    e.stopPropagation();
                };
                
                // Bind events specifically to this terminal
                header.addEventListener('mousedown', onMouseDown);
                
                // Store cleanup function
                terminal._dragCleanup = () => {
                    header.removeEventListener('mousedown', onMouseDown);
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                };
                
                // Global move and up events
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            }

            // Setup terminal resize (desktop only)
            setupTerminalResize(terminal) {
                if (window.innerWidth <= 768) return;
                
                const handles = terminal.querySelectorAll('.resize-handle');
                let resizeData = null;
                
                const minWidth = 400;
                const minHeight = 300;
                
                handles.forEach(handle => {
                    handle.addEventListener('mousedown', (e) => {
                        this.isResizing = true;
                        resizeData = {
                            handle: handle,
                            startX: e.clientX,
                            startY: e.clientY,
                            startWidth: terminal.offsetWidth,
                            startHeight: terminal.offsetHeight,
                            startLeft: terminal.offsetLeft,
                            startTop: terminal.offsetTop
                        };
                        
                        e.preventDefault();
                        e.stopPropagation();
                    });
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (!this.isResizing || !resizeData) return;
                    
                    const deltaX = e.clientX - resizeData.startX;
                    const deltaY = e.clientY - resizeData.startY;
                    const handleClass = resizeData.handle.className;
                    
                    let newWidth = resizeData.startWidth;
                    let newHeight = resizeData.startHeight;
                    let newLeft = resizeData.startLeft;
                    let newTop = resizeData.startTop;
                    
                    if (handleClass.includes('se')) {
                        newWidth = Math.max(minWidth, resizeData.startWidth + deltaX);
                        newHeight = Math.max(minHeight, resizeData.startHeight + deltaY);
                    } else if (handleClass.includes('sw')) {
                        newWidth = Math.max(minWidth, resizeData.startWidth - deltaX);
                        newHeight = Math.max(minHeight, resizeData.startHeight + deltaY);
                        newLeft = resizeData.startLeft + (resizeData.startWidth - newWidth);
                    } else if (handleClass.includes('ne')) {
                        newWidth = Math.max(minWidth, resizeData.startWidth + deltaX);
                        newHeight = Math.max(minHeight, resizeData.startHeight - deltaY);
                        newTop = resizeData.startTop + (resizeData.startHeight - newHeight);
                    } else if (handleClass.includes('nw')) {
                        newWidth = Math.max(minWidth, resizeData.startWidth - deltaX);
                        newHeight = Math.max(minHeight, resizeData.startHeight - deltaY);
                        newLeft = resizeData.startLeft + (resizeData.startWidth - newWidth);
                        newTop = resizeData.startTop + (resizeData.startHeight - newHeight);
                    } else if (handleClass.includes('e')) {
                        newWidth = Math.max(minWidth, resizeData.startWidth + deltaX);
                    } else if (handleClass.includes('w')) {
                        newWidth = Math.max(minWidth, resizeData.startWidth - deltaX);
                        newLeft = resizeData.startLeft + (resizeData.startWidth - newWidth);
                    } else if (handleClass.includes('s')) {
                        newHeight = Math.max(minHeight, resizeData.startHeight + deltaY);
                    } else if (handleClass.includes('n')) {
                        newHeight = Math.max(minHeight, resizeData.startHeight - deltaY);
                        newTop = resizeData.startTop + (resizeData.startHeight - newHeight);
                    }
                    
                    requestAnimationFrame(() => {
                        terminal.style.width = `${newWidth}px`;
                        terminal.style.height = `${newHeight}px`;
                        terminal.style.left = `${newLeft}px`;
                        terminal.style.top = `${newTop}px`;
                    });
                });
                
                document.addEventListener('mouseup', () => {
                    if (!this.isResizing) return;
                    
                    this.isResizing = false;
                    resizeData = null;
                });
            }

            // Setup terminal input
            setupTerminalInput(terminal) {
                const input = terminal.querySelector('.terminal-input');
                const content = terminal.querySelector('.terminal-content');
                
                // Placeholder rotation
                const placeholders = [
                    'help - show available commands',
                    'quote - get inspirational quote',
                    'games - play retro games',
                    'matrix - toggle matrix rain',
                    'clear - clear terminal',
                    'whoami - system information'
                ];
                
                let placeholderIndex = 0;
                const rotatePlaceholder = () => {
                    input.placeholder = placeholders[placeholderIndex];
                    placeholderIndex = (placeholderIndex + 1) % placeholders.length;
                };
                
                rotatePlaceholder();
                const placeholderInterval = setInterval(rotatePlaceholder, 3000);
                
                // Command handling
                input.addEventListener('keydown', async (e) => {
                    if (e.key === 'Enter') {
                        const command = input.value.trim();
                        input.value = '';
                        
                        if (command) {
                            this.addCommandLine(content, command);
                            await this.executeCommand(command, content, terminal);
                        }
                    }
                });
                
                // Clean up interval when terminal is closed
                terminal.addEventListener('beforeunload', () => {
                    clearInterval(placeholderInterval);
                });
            }

            // Add command line to terminal
            addCommandLine(content, command) {
                const commandLine = document.createElement('div');
                commandLine.className = 'command-line';
                commandLine.innerHTML = `
                    <span class="prompt">user@neon-oracle:~$</span>
                    <span class="command">${this.escapeHtml(command)}</span>
                `;
                content.appendChild(commandLine);
                this.scrollToBottom(content);
            }

            // Add response to terminal
            addResponse(content, text, className = 'response') {
                const response = document.createElement('div');
                response.className = className;
                response.innerHTML = text;
                content.appendChild(response);
                this.scrollToBottom(content);
                return response;
            }

            // Scroll to bottom
            scrollToBottom(content) {
                requestAnimationFrame(() => {
                    content.scrollTop = content.scrollHeight;
                });
            }

            // Escape HTML
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            // Execute command
            async executeCommand(command, content, terminal) {
                const cmd = command.toLowerCase();
                
                switch (cmd) {
                    case 'help':
                        this.showHelp(content);
                        break;
                    case 'quote':
                        await this.showQuote(content);
                        break;
                    case 'games':
                        this.showGameMenu();
                        break;
                    case 'snake':
                        this.startGame('snake');
                        break;
                    case 'tetris':
                        this.startGame('tetris');
                        break;
                    case 'pong':
                        this.startGame('pong');
                        break;
                    case 'matrix':
                        this.toggleMatrix(content);
                        break;
                    case 'clear':
                        content.innerHTML = '';
                        break;
                    case 'whoami':
                        this.showSystemInfo(content);
                        break;
                    case 'exit':
                    case 'quit':
                        this.closeTerminal(terminal);
                        break;
                    case 'hack':
                        await this.runHackSequence(content);
                        break;
                    case 'love':
                        await this.showLove(content);
                        break;
                    case 'neofetch':
                        this.showNeofetch(content);
                        break;
                    default:
                        this.addResponse(content, `Command not found: ${command}`, 'response error');
                        this.addResponse(content, "Type 'help' for available commands.", 'response');
                }
            }

            // Show help
            showHelp(content) {
                const helpText = `
<span class="success">Available Commands:</span>

<span class="info">System Commands:</span>
  help      - Show this help message
  clear     - Clear terminal screen
  exit      - Close terminal
  whoami    - Show system information
  neofetch  - Display system info with ASCII art

<span class="info">Content Commands:</span>
  quote     - Get inspirational quote
  matrix    - Toggle matrix rain effect

<span class="info">Games & Entertainment:</span>
  games     - Open games menu
  snake     - Play Snake game
  tetris    - Play Tetris
  pong      - Play Pong

<span class="info">Easter Eggs:</span>
  hack      - Run hacking simulation
  love      - Show some love â¤ï¸

<span class="warning">Tip:</span> Use Ctrl+T for new terminal, Ctrl+W to close current terminal
                `;
                this.addResponse(content, helpText);
            }

            // Show quote
            async showQuote(content) {
                const loadingResponse = this.addResponse(content, 'Fetching wisdom from the Oracle <span class="loading-dots"><span></span><span></span><span></span></span>');
                
                // Simulate loading delay
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                const quote = this.getRandomQuote();
                if (quote) {
                    loadingResponse.remove();
                    
                    const quoteSection = document.createElement('div');
                    quoteSection.className = 'quote-section';
                    quoteSection.innerHTML = `
                        <div class="quote-text">"${quote.text}"</div>
                        <div class="quote-author">â€” ${quote.author}</div>
                        <div class="share-container">
                            <button class="terminal-button" onclick="navigator.clipboard.writeText('${quote.text} â€” ${quote.author}')">
                                <i class="ph ph-copy"></i> Copy
                            </button>
                            <button class="terminal-button" onclick="window.open('https://twitter.com/intent/tweet?text=${encodeURIComponent(quote.text + ' â€” ' + quote.author)}', '_blank')">
                                <i class="ph ph-twitter-logo"></i> Tweet
                            </button>
                        </div>
                    `;
                    content.appendChild(quoteSection);
                } else {
                    loadingResponse.innerHTML = '<span class="error">Failed to fetch quote. Try again later.</span>';
                }
                
                this.scrollToBottom(content);
            }

            // Show system info
            showSystemInfo(content) {
                const info = `
<span class="success">System Information:</span>
User: neon-oracle-user
OS: Neon Oracle Linux v3.0
Kernel: 6.1.0-neon
Shell: /bin/neon-bash
Terminal: Neon Terminal Emulator
Uptime: ${this.getUptime()}
Memory: ${this.getMemoryInfo()}
CPU: Quantum Processing Unit
Network: Connected to the Matrix
                `;
                this.addResponse(content, info);
            }

            // Show neofetch
            showNeofetch(content) {
                const asciiArt = `
    <pre class="ascii-art">
        â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
        â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â•â•â•
           â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  
           â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â•  
           â–ˆâ–ˆâ•‘   â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
           â•šâ•â•    â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•
    </pre>
                `;
                
                const systemInfo = `
<span class="info">OS:</span> Neon Oracle Linux v3.0
<span class="info">Host:</span> Quantum Mainframe
<span class="info">Kernel:</span> 6.1.0-neon-oracle
<span class="info">Uptime:</span> ${this.getUptime()}
<span class="info">Shell:</span> neon-bash 5.1.16
<span class="info">Terminal:</span> Neon Terminal Emulator
<span class="info">CPU:</span> Quantum Processing Unit (8 cores)
<span class="info">GPU:</span> Neural Graphics Processor
<span class="info">Memory:</span> ${this.getMemoryInfo()}
                `;
                
                this.addResponse(content, asciiArt + systemInfo);
            }

            // Get uptime
            getUptime() {
                const start = performance.now();
                const seconds = Math.floor(start / 1000);
                const minutes = Math.floor(seconds / 60);
                const hours = Math.floor(minutes / 60);
                return `${hours}h ${minutes % 60}m ${seconds % 60}s`;
            }

            // Get memory info
            getMemoryInfo() {
                if (navigator.deviceMemory) {
                    return `${navigator.deviceMemory}GB`;
                }
                return '8GB (estimated)';
            }

            // Toggle matrix rain
            toggleMatrix(content) {
                const matrixRain = document.querySelector('.matrix-rain');
                const isVisible = matrixRain.style.opacity !== '0';
                
                if (isVisible) {
                    matrixRain.style.opacity = '0';
                    this.addResponse(content, '<span class="success">Matrix rain disabled</span>');
                } else {
                    matrixRain.style.opacity = '0.1';
                    this.addResponse(content, '<span class="success">Matrix rain enabled</span>');
                }
            }

            // Run hack sequence - Enhanced with progress bar
            async runHackSequence(content) {
                const hackMessages = [
                    'Initializing hack sequence...',
                    'Bypassing firewall protocols...',
                    'Scanning network vulnerabilities...',
                    'Injecting payload into mainframe...',
                    'Cracking 256-bit encryption...',
                    'Accessing secure databases...',
                    'Extracting classified files...',
                    'Installing backdoor access...',
                    'Erasing digital footprints...',
                    'Laundering through proxy chains...',
                    'Final system penetration...',
                    'Mission accomplished! ðŸŽ¯'
                ];
                
                // Create progress bar
                const progressContainer = document.createElement('div');
                progressContainer.innerHTML = `
                    <div class="progress-bar">
                        <div class="progress-fill" id="hackProgress"></div>
                    </div>
                `;
                content.appendChild(progressContainer);
                
                const progressBar = progressContainer.querySelector('#hackProgress');
                
                for (let i = 0; i < hackMessages.length; i++) {
                    const message = hackMessages[i];
                    const isLast = i === hackMessages.length - 1;
                    const className = isLast ? 'response success' : 'response';
                    
                    this.addResponse(content, message, className);
                    
                    // Update progress bar
                    const progress = ((i + 1) / hackMessages.length) * 100;
                    progressBar.style.width = `${progress}%`;
                    
                    await new Promise(resolve => setTimeout(resolve, 600));
                }
                
                // Remove progress bar and redirect - FIXED
                setTimeout(() => {
                    progressContainer.remove();
                    this.addResponse(content, '<span class="success">Opening secure terminal...</span>');
                    setTimeout(() => {
                        window.open('https://www.youtube.com/watch?v=qbWqXKN3m3c', '_blank');
                    }, 1000);
                }, 500);
            }

            // Show love - Enhanced with redirect
            async showLove(content) {
                const loveText = `
<span style="color: #ff69b4;">
   â¤ï¸  â¤ï¸  â¤ï¸  â¤ï¸  â¤ï¸  â¤ï¸  â¤ï¸  â¤ï¸  â¤ï¸
  â¤ï¸  Made with love by the Oracle  â¤ï¸
   â¤ï¸  â¤ï¸  â¤ï¸  â¤ï¸  â¤ï¸  â¤ï¸  â¤ï¸  â¤ï¸  â¤ï¸
</span>

<span class="success">Loading special message...</span>
                `;
                this.addResponse(content, loveText);
                
                // Wait and redirect
                setTimeout(() => {
                    this.addResponse(content, '<span class="info">Redirecting to a special message from the Oracle... ðŸ’</span>');
                    setTimeout(() => {
                        window.open('https://www.youtube.com/watch?v=tb4ozEOZh8U', '_blank');
                    }, 2000);
                }, 1500);
            }

            // Initialize terminal content
            async initTerminalContent(terminal) {
                const content = terminal.querySelector('.terminal-content');
                
                // Welcome message
                const welcomeArt = `
    <pre class="ascii-art">
    â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—
    â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘
    â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘
    â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘
    â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘
    â•šâ•â•  â•šâ•â•â•â•â•šâ•â•â•â•â•â•â• â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•â•â•
                      
     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
    â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â•â•â•
    â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  
    â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â•  
    â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
     â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•
                      
                      v3.0 - Modern Edition
    </pre>
                `;
                
                this.addResponse(content, welcomeArt);
                this.addResponse(content, '<span class="success">Welcome to Neon Oracle v3.0 - Modern Edition</span>');
                this.addResponse(content, '<span class="info">Now loading quotes from GitHub repository!</span>');
                this.addResponse(content, "Type 'help' to see available commands or 'quote' for wisdom.");
                
                // Auto-fetch first quote
                setTimeout(() => {
                    this.executeCommand('quote', content, terminal);
                }, 1000);
            }

            // Show game menu
            showGameMenu() {
                if (this.activeTerminal) {
                    const content = this.activeTerminal.querySelector('.terminal-content');
                    const gameMenu = `
<span class="success">ðŸŽ® Game Menu</span>

Available Games:
  <span class="info">snake</span>  - Classic Snake game
  <span class="info">tetris</span> - Block puzzle game
  <span class="info">pong</span>   - Retro ping pong

Type the game name to start playing!
                    `;
                    this.addResponse(content, gameMenu);
                }
            }

            // Start game - FIXED
            startGame(gameName) {
                const gameOverlay = document.getElementById('gameOverlay');
                const canvas = document.getElementById('gameCanvas');
                const ctx = canvas.getContext('2d');
                
                // Clear previous game
                if (this.gameInstance) {
                    this.gameInstance.stop();
                    this.gameInstance = null;
                }
                
                // Reset canvas size
                canvas.width = 400;
                canvas.height = 400;
                
                // Show game overlay and canvas
                gameOverlay.classList.add('active');
                canvas.classList.add('active');
                
                // Clear canvas
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Small delay to ensure DOM is updated
                setTimeout(() => {
                    // Create game instance
                    switch (gameName) {
                        case 'snake':
                            this.gameInstance = new SnakeGame(ctx, canvas);
                            break;
                        case 'tetris':
                            this.gameInstance = new TetrisGame(ctx, canvas);
                            break;
                        case 'pong':
                            this.gameInstance = new PongGame(ctx, canvas);
                            break;
                    }
                }, 50);
            }

            // Close game
            closeGame() {
                const gameOverlay = document.getElementById('gameOverlay');
                const canvas = document.getElementById('gameCanvas');
                
                gameOverlay.classList.remove('active');
                canvas.classList.remove('active');
                
                if (this.gameInstance) {
                    this.gameInstance.stop();
                    this.gameInstance = null;
                }
                
                // Clear canvas
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // Register service worker for PWA
            async registerServiceWorker() {
                if ('serviceWorker' in navigator) {
                    try {
                        const registration = await navigator.serviceWorker.register('/sw.js');
                        console.log('ServiceWorker registered:', registration);
                    } catch (error) {
                        console.log('ServiceWorker registration failed:', error);
                    }
                }
            }
        }

        // Snake Game Class - FIXED AND IMPROVED
        class SnakeGame {
            constructor(ctx, canvas) {
                this.ctx = ctx;
                this.canvas = canvas;
                this.gridSize = 20;
                this.snake = [{ x: 200, y: 200 }];
                this.food = this.generateFood();
                this.direction = { x: 0, y: 0 };
                this.score = 0;
                this.gameRunning = true;
                this.lastTime = 0;
                this.gameSpeed = 150; // milliseconds
                
                console.log('Snake game initialized');
                this.bindEvents();
                
                // Start the game loop
                requestAnimationFrame((time) => this.gameLoop(time));
            }
            
            generateFood() {
                let newFood;
                do {
                    newFood = {
                        x: Math.floor(Math.random() * (this.canvas.width / this.gridSize)) * this.gridSize,
                        y: Math.floor(Math.random() * (this.canvas.height / this.gridSize)) * this.gridSize
                    };
                } while (this.snake.some(segment => segment.x === newFood.x && segment.y === newFood.y));
                
                return newFood;
            }
            
            bindEvents() {
                this.keyHandler = (e) => {
                    if (!this.gameRunning) return;
                    
                    e.preventDefault();
                    switch (e.key) {
                        case 'ArrowUp':
                        case 'w':
                        case 'W':
                            if (this.direction.y === 0) this.direction = { x: 0, y: -this.gridSize };
                            break;
                        case 'ArrowDown':
                        case 's':
                        case 'S':
                            if (this.direction.y === 0) this.direction = { x: 0, y: this.gridSize };
                            break;
                        case 'ArrowLeft':
                        case 'a':
                        case 'A':
                            if (this.direction.x === 0) this.direction = { x: -this.gridSize, y: 0 };
                            break;
                        case 'ArrowRight':
                        case 'd':
                        case 'D':
                            if (this.direction.x === 0) this.direction = { x: this.gridSize, y: 0 };
                            break;
                    }
                };
                document.addEventListener('keydown', this.keyHandler);
            }
            
            gameLoop(currentTime) {
                if (!this.gameRunning) return;
                
                if (currentTime - this.lastTime >= this.gameSpeed) {
                    this.update();
                    this.lastTime = currentTime;
                }
                
                this.draw();
                requestAnimationFrame((time) => this.gameLoop(time));
            }
            
            update() {
                if (this.direction.x === 0 && this.direction.y === 0) return;
                
                const head = { x: this.snake[0].x + this.direction.x, y: this.snake[0].y + this.direction.y };
                
                // Check collision with walls
                if (head.x < 0 || head.x >= this.canvas.width || head.y < 0 || head.y >= this.canvas.height) {
                    this.gameOver();
                    return;
                }
                
                // Check collision with self
                if (this.snake.some(segment => segment.x === head.x && segment.y === head.y)) {
                    this.gameOver();
                    return;
                }
                
                this.snake.unshift(head);
                
                // Check food collision
                if (head.x === this.food.x && head.y === this.food.y) {
                    this.score += 10;
                    this.food = this.generateFood();
                    // Increase speed slightly
                    this.gameSpeed = Math.max(80, this.gameSpeed - 2);
                } else {
                    this.snake.pop();
                }
            }
            
            draw() {
                // Clear canvas
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw snake
                this.ctx.fillStyle = '#00ff41';
                this.snake.forEach((segment, index) => {
                    if (index === 0) {
                        // Head is brighter
                        this.ctx.fillStyle = '#00ff41';
                    } else {
                        this.ctx.fillStyle = '#008f11';
                    }
                    this.ctx.fillRect(segment.x + 1, segment.y + 1, this.gridSize - 2, this.gridSize - 2);
                    this.ctx.fillStyle = '#00ff41';
                });
                
                // Draw food
                this.ctx.fillStyle = '#ff0080';
                this.ctx.fillRect(this.food.x + 1, this.food.y + 1, this.gridSize - 2, this.gridSize - 2);
                
                // Draw score and instructions
                this.ctx.fillStyle = '#fff';
                this.ctx.font = '16px Fira Code';
                this.ctx.fillText(`Score: ${this.score}`, 10, 30);
                this.ctx.fillText('Use WASD or arrow keys', 10, 50);
                this.ctx.fillText('Press ESC to exit', 10, 70);
            }
            
            gameOver() {
                this.gameRunning = false;
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.fillStyle = '#ff0080';
                this.ctx.font = '24px Fira Code';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Game Over!', this.canvas.width / 2, this.canvas.height / 2 - 20);
                this.ctx.fillText(`Final Score: ${this.score}`, this.canvas.width / 2, this.canvas.height / 2 + 10);
                this.ctx.fillText('Press ESC to close', this.canvas.width / 2, this.canvas.height / 2 + 40);
                this.ctx.textAlign = 'left';
            }
            
            stop() {
                this.gameRunning = false;
                document.removeEventListener('keydown', this.keyHandler);
            }
        }

        // Tetris Game Class - FIXED AND IMPROVED
        class TetrisGame {
            constructor(ctx, canvas) {
                this.ctx = ctx;
                this.canvas = canvas;
                this.gridSize = 20;
                this.cols = Math.floor(this.canvas.width / this.gridSize);
                this.rows = Math.floor(this.canvas.height / this.gridSize);
                this.board = Array(this.rows).fill().map(() => Array(this.cols).fill(0));
                this.currentPiece = this.generatePiece();
                this.score = 0;
                this.lines = 0;
                this.level = 1;
                this.gameRunning = true;
                this.lastTime = 0;
                this.dropTime = 0;
                this.dropInterval = 1000;
                
                console.log('Tetris game initialized');
                this.bindEvents();
                
                // Start the game loop
                requestAnimationFrame((time) => this.gameLoop(time));
            }
            
            generatePiece() {
                const pieces = [
                    { shape: [[1, 1, 1, 1]], color: '#00ffff' }, // I
                    { shape: [[1, 1], [1, 1]], color: '#ffff00' }, // O
                    { shape: [[0, 1, 0], [1, 1, 1]], color: '#800080' }, // T
                    { shape: [[1, 0, 0], [1, 1, 1]], color: '#ffa500' }, // L
                    { shape: [[0, 0, 1], [1, 1, 1]], color: '#0000ff' }, // J
                    { shape: [[0, 1, 1], [1, 1, 0]], color: '#00ff00' }, // S
                    { shape: [[1, 1, 0], [0, 1, 1]], color: '#ff0000' }  // Z
                ];
                
                const pieceData = pieces[Math.floor(Math.random() * pieces.length)];
                return {
                    shape: pieceData.shape,
                    color: pieceData.color,
                    x: Math.floor(this.cols / 2) - Math.floor(pieceData.shape[0].length / 2),
                    y: 0
                };
            }
            
            bindEvents() {
                this.keyHandler = (e) => {
                    if (!this.gameRunning) return;
                    
                    e.preventDefault();
                    switch (e.key) {
                        case 'ArrowLeft':
                        case 'a':
                        case 'A':
                            this.movePiece(-1, 0);
                            break;
                        case 'ArrowRight':
                        case 'd':
                        case 'D':
                            this.movePiece(1, 0);
                            break;
                        case 'ArrowDown':
                        case 's':
                        case 'S':
                            this.movePiece(0, 1);
                            break;
                        case 'ArrowUp':
                        case 'w':
                        case 'W':
                        case ' ':
                            this.rotatePiece();
                            break;
                    }
                };
                document.addEventListener('keydown', this.keyHandler);
            }
            
            movePiece(dx, dy) {
                const newX = this.currentPiece.x + dx;
                const newY = this.currentPiece.y + dy;
                
                if (this.isValidPosition(this.currentPiece.shape, newX, newY)) {
                    this.currentPiece.x = newX;
                    this.currentPiece.y = newY;
                    return true;
                }
                return false;
            }
            
            rotatePiece() {
                const rotated = this.currentPiece.shape[0].map((_, index) =>
                    this.currentPiece.shape.map(row => row[index]).reverse()
                );
                
                if (this.isValidPosition(rotated, this.currentPiece.x, this.currentPiece.y)) {
                    this.currentPiece.shape = rotated;
                }
            }
            
            isValidPosition(shape, x, y) {
                for (let row = 0; row < shape.length; row++) {
                    for (let col = 0; col < shape[row].length; col++) {
                        if (shape[row][col]) {
                            const newX = x + col;
                            const newY = y + row;
                            
                            if (newX < 0 || newX >= this.cols || newY >= this.rows || 
                                (newY >= 0 && this.board[newY][newX])) {
                                return false;
                            }
                        }
                    }
                }
                return true;
            }
            
            gameLoop(currentTime) {
                if (!this.gameRunning) return;
                
                const deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;
                this.dropTime += deltaTime;
                
                if (this.dropTime > this.dropInterval) {
                    if (!this.movePiece(0, 1)) {
                        this.placePiece();
                        this.clearLines();
                        this.currentPiece = this.generatePiece();
                        
                        if (!this.isValidPosition(this.currentPiece.shape, this.currentPiece.x, this.currentPiece.y)) {
                            this.gameOver();
                        }
                    }
                    this.dropTime = 0;
                }
                
                this.draw();
                requestAnimationFrame((time) => this.gameLoop(time));
            }
            
            placePiece() {
                for (let row = 0; row < this.currentPiece.shape.length; row++) {
                    for (let col = 0; col < this.currentPiece.shape[row].length; col++) {
                        if (this.currentPiece.shape[row][col]) {
                            const x = this.currentPiece.x + col;
                            const y = this.currentPiece.y + row;
                            if (y >= 0) {
                                this.board[y][x] = this.currentPiece.color;
                            }
                        }
                    }
                }
            }
            
            clearLines() {
                let linesCleared = 0;
                for (let row = this.rows - 1; row >= 0; row--) {
                    if (this.board[row].every(cell => cell !== 0)) {
                        this.board.splice(row, 1);
                        this.board.unshift(Array(this.cols).fill(0));
                        linesCleared++;
                        row++; // Check the same row again
                    }
                }
                
                if (linesCleared > 0) {
                    this.lines += linesCleared;
                    this.score += linesCleared * 100 * this.level;
                    this.level = Math.floor(this.lines / 10) + 1;
                    this.dropInterval = Math.max(100, 1000 - (this.level - 1) * 50);
                }
            }
            
            draw() {
                // Clear canvas
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw board
                for (let row = 0; row < this.rows; row++) {
                    for (let col = 0; col < this.cols; col++) {
                        if (this.board[row][col]) {
                            this.ctx.fillStyle = this.board[row][col];
                            this.ctx.fillRect(col * this.gridSize + 1, row * this.gridSize + 1, 
                                            this.gridSize - 2, this.gridSize - 2);
                        }
                    }
                }
                
                // Draw current piece
                this.ctx.fillStyle = this.currentPiece.color;
                for (let row = 0; row < this.currentPiece.shape.length; row++) {
                    for (let col = 0; col < this.currentPiece.shape[row].length; col++) {
                        if (this.currentPiece.shape[row][col]) {
                            const x = (this.currentPiece.x + col) * this.gridSize;
                            const y = (this.currentPiece.y + row) * this.gridSize;
                            this.ctx.fillRect(x + 1, y + 1, this.gridSize - 2, this.gridSize - 2);
                        }
                    }
                }
                
                // Draw grid lines
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 1;
                for (let i = 0; i <= this.cols; i++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(i * this.gridSize, 0);
                    this.ctx.lineTo(i * this.gridSize, this.canvas.height);
                    this.ctx.stroke();
                }
                for (let i = 0; i <= this.rows; i++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, i * this.gridSize);
                    this.ctx.lineTo(this.canvas.width, i * this.gridSize);
                    this.ctx.stroke();
                }
                
                // Draw UI
                this.ctx.fillStyle = '#fff';
                this.ctx.font = '14px Fira Code';
                this.ctx.fillText(`Score: ${this.score}`, 10, 25);
                this.ctx.fillText(`Lines: ${this.lines}`, 10, 45);
                this.ctx.fillText(`Level: ${this.level}`, 10, 65);
                this.ctx.fillText('WASD/Arrows: Move', 10, this.canvas.height - 60);
                this.ctx.fillText('W/Up/Space: Rotate', 10, this.canvas.height - 40);
                this.ctx.fillText('ESC: Exit', 10, this.canvas.height - 20);
            }
            
            gameOver() {
                this.gameRunning = false;
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.fillStyle = '#ff0080';
                this.ctx.font = '24px Fira Code';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Game Over!', this.canvas.width / 2, this.canvas.height / 2 - 30);
                this.ctx.fillText(`Score: ${this.score}`, this.canvas.width / 2, this.canvas.height / 2);
                this.ctx.fillText(`Lines: ${this.lines}`, this.canvas.width / 2, this.canvas.height / 2 + 30);
                this.ctx.fillText('Press ESC to close', this.canvas.width / 2, this.canvas.height / 2 + 60);
                this.ctx.textAlign = 'left';
            }
            
            stop() {
                this.gameRunning = false;
                document.removeEventListener('keydown', this.keyHandler);
            }
        }

        // Pong Game Class - FIXED AND IMPROVED
        class PongGame {
            constructor(ctx, canvas) {
                this.ctx = ctx;
                this.canvas = canvas;
                this.paddle1 = { x: 10, y: canvas.height / 2 - 50, width: 10, height: 100, speed: 6 };
                this.paddle2 = { x: canvas.width - 20, y: canvas.height / 2 - 50, width: 10, height: 100, speed: 6 };
                this.ball = { 
                    x: canvas.width / 2, 
                    y: canvas.height / 2, 
                    dx: 4 * (Math.random() > 0.5 ? 1 : -1), 
                    dy: 4 * (Math.random() > 0.5 ? 1 : -1), 
                    radius: 8,
                    speed: 4
                };
                this.score = { player1: 0, player2: 0 };
                this.gameRunning = true;
                this.keys = {};
                this.lastTime = 0;
                
                console.log('Pong game initialized');
                this.bindEvents();
                
                // Start the game loop
                requestAnimationFrame((time) => this.gameLoop(time));
            }
            
            bindEvents() {
                this.keyDownHandler = (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    e.preventDefault();
                };
                this.keyUpHandler = (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                    e.preventDefault();
                };
                
                document.addEventListener('keydown', this.keyDownHandler);
                document.addEventListener('keyup', this.keyUpHandler);
            }
            
            gameLoop(currentTime) {
                if (!this.gameRunning) return;
                
                const deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;
                
                this.update();
                this.draw();
                
                requestAnimationFrame((time) => this.gameLoop(time));
            }
            
            update() {
                // Move paddles
                if ((this.keys['arrowup'] || this.keys['w']) && this.paddle2.y > 0) {
                    this.paddle2.y -= this.paddle2.speed;
                }
                if ((this.keys['arrowdown'] || this.keys['s']) && this.paddle2.y < this.canvas.height - this.paddle2.height) {
                    this.paddle2.y += this.paddle2.speed;
                }
                
                // Simple AI for left paddle
                const paddleCenter = this.paddle1.y + this.paddle1.height / 2;
                if (paddleCenter < this.ball.y - 35) {
                    this.paddle1.y += this.paddle1.speed * 0.7;
                } else if (paddleCenter > this.ball.y + 35) {
                    this.paddle1.y -= this.paddle1.speed * 0.7;
                }
                
                // Keep paddles in bounds
                this.paddle1.y = Math.max(0, Math.min(this.canvas.height - this.paddle1.height, this.paddle1.y));
                this.paddle2.y = Math.max(0, Math.min(this.canvas.height - this.paddle2.height, this.paddle2.y));
                
                // Move ball
                this.ball.x += this.ball.dx;
                this.ball.y += this.ball.dy;
                
                // Ball collision with top/bottom
                if (this.ball.y <= this.ball.radius || this.ball.y >= this.canvas.height - this.ball.radius) {
                    this.ball.dy = -this.ball.dy;
                }
                
                // Ball collision with paddles
                if (this.ball.x - this.ball.radius <= this.paddle1.x + this.paddle1.width && 
                    this.ball.y >= this.paddle1.y - this.ball.radius && 
                    this.ball.y <= this.paddle1.y + this.paddle1.height + this.ball.radius &&
                    this.ball.dx < 0) {
                    this.ball.dx = -this.ball.dx;
                    this.ball.x = this.paddle1.x + this.paddle1.width + this.ball.radius;
                    
                    // Add some angle based on where ball hits paddle
                    const hitPos = (this.ball.y - (this.paddle1.y + this.paddle1.height / 2)) / (this.paddle1.height / 2);
                    this.ball.dy = hitPos * this.ball.speed;
                }
                
                if (this.ball.x + this.ball.radius >= this.paddle2.x && 
                    this.ball.y >= this.paddle2.y - this.ball.radius && 
                    this.ball.y <= this.paddle2.y + this.paddle2.height + this.ball.radius &&
                    this.ball.dx > 0) {
                    this.ball.dx = -this.ball.dx;
                    this.ball.x = this.paddle2.x - this.ball.radius;
                    
                    // Add some angle based on where ball hits paddle
                    const hitPos = (this.ball.y - (this.paddle2.y + this.paddle2.height / 2)) / (this.paddle2.height / 2);
                    this.ball.dy = hitPos * this.ball.speed;
                }
                
                // Score
                if (this.ball.x < 0) {
                    this.score.player2++;
                    this.resetBall();
                }
                if (this.ball.x > this.canvas.width) {
                    this.score.player1++;
                    this.resetBall();
                }
                
                // Check win condition
                if (this.score.player1 >= 5 || this.score.player2 >= 5) {
                    this.gameOver();
                }
            }
            
            resetBall() {
                this.ball.x = this.canvas.width / 2;
                this.ball.y = this.canvas.height / 2;
                this.ball.dx = this.ball.speed * (Math.random() > 0.5 ? 1 : -1);
                this.ball.dy = this.ball.speed * (Math.random() > 0.5 ? 1 : -1);
            }
            
            draw() {
                // Clear canvas
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw center line
                this.ctx.setLineDash([5, 15]);
                this.ctx.beginPath();
                this.ctx.moveTo(this.canvas.width / 2, 0);
                this.ctx.lineTo(this.canvas.width / 2, this.canvas.height);
                this.ctx.strokeStyle = '#333';
                this.ctx.stroke();
                this.ctx.setLineDash([]);
                
                // Draw paddles
                this.ctx.fillStyle = '#00ff41';
                this.ctx.fillRect(this.paddle1.x, this.paddle1.y, this.paddle1.width, this.paddle1.height);
                this.ctx.fillRect(this.paddle2.x, this.paddle2.y, this.paddle2.width, this.paddle2.height);
                
                // Draw ball
                this.ctx.fillStyle = '#ff0080';
                this.ctx.beginPath();
                this.ctx.arc(this.ball.x, this.ball.y, this.ball.radius, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Draw score
                this.ctx.fillStyle = '#fff';
                this.ctx.font = '32px Fira Code';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(this.score.player1, this.canvas.width / 4, 60);
                this.ctx.fillText(this.score.player2, 3 * this.canvas.width / 4, 60);
                
                // Draw instructions
                this.ctx.font = '12px Fira Code';
                this.ctx.fillText('CPU vs Player', this.canvas.width / 2, this.canvas.height - 60);
                this.ctx.fillText('Player: W/S or â†‘/â†“', this.canvas.width / 2, this.canvas.height - 40);
                this.ctx.fillText('First to 5 wins! Press ESC to exit', this.canvas.width / 2, this.canvas.height - 20);
                this.ctx.textAlign = 'left';
            }
            
            gameOver() {
                this.gameRunning = false;
                const winner = this.score.player1 >= 5 ? 'CPU' : 'Player';
                
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.fillStyle = '#ff0080';
                this.ctx.font = '24px Fira Code';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(`${winner} Wins!`, this.canvas.width / 2, this.canvas.height / 2 - 20);
                this.ctx.fillText(`Final Score: ${this.score.player1} - ${this.score.player2}`, this.canvas.width / 2, this.canvas.height / 2 + 10);
                this.ctx.fillText('Press ESC to close', this.canvas.width / 2, this.canvas.height / 2 + 40);
                this.ctx.textAlign = 'left';
            }
            
            stop() {
                this.gameRunning = false;
                document.removeEventListener('keydown', this.keyDownHandler);
                document.removeEventListener('keyup', this.keyUpHandler);
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            new NeonOracle();
        });
    </script>
</body>
</html>
