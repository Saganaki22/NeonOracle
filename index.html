<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Neon Oracle :: Modern Linux Terminal</title>

    <!-- Meta Description -->
    <meta name="description" content="Modern Neon Oracle - A stylish, terminal-themed web application with games, quotes, and retro computing vibes.">

    <!-- Favicon Links -->
    <link rel="apple-touch-icon" sizes="180x180" href="favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon/favicon-16x16.png">
    <link rel="manifest" href="favicon/webmanifest.json">
    <link rel="shortcut icon" href="favicon/favicon.ico">

    <!-- Open Graph Meta Tags (for social sharing) -->
    <meta property="og:title" content="Neon Oracle :: Linux Terminal">
    <meta property="og:description" content="Neon Oracle is a stylish, terminal-themed web application that generates and displays inspirational quotes in a nostalgic command-line interface.">
    <meta property="og:image" content="https://i.ibb.co/9kLdSDzp/neonoracle.jpg">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://saganaki22.github.io/NeonOracle/">

    <!-- Twitter Card (for better previews on Twitter) -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Neon Oracle :: Linux Terminal">
    <meta name="twitter:description" content="Neon Oracle is a stylish, terminal-themed web application that generates and displays inspirational quotes in a nostalgic command-line interface.">
    <meta name="twitter:image" content="https://i.ibb.co/9kLdSDzp/neonoracle.jpg">

    <!-- PWA Manifest -->
    <link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiTmVvbiBPcmFjbGUiLCJzaG9ydF9uYW1lIjoiTmVvbk9yYWNsZSIsImRlc2NyaXB0aW9uIjoiTW9kZXJuIHRlcm1pbmFsIGludGVyZmFjZSIsInN0YXJ0X3VybCI6Ii8iLCJkaXNwbGF5Ijoic3RhbmRhbG9uZSIsInRoZW1lX2NvbG9yIjoiIzAwMDAwMCIsImJhY2tncm91bmRfY29sb3IiOiIjMDAwMDAwIn0=">

    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300;400;500;600;700&family=JetBrains+Mono:wght@100;200;300;400;500;600;700;800&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/@phosphor-icons/web"></script>

    <style>
        /* Modern CSS Custom Properties */
        :root {
            --terminal-primary: #00ff41;
            --terminal-secondary: #008f11;
            --terminal-accent: #ff0080;
            --terminal-warning: #ffaa00;
            --terminal-error: #ff3030;
            --terminal-white: #ffffff;
            --terminal-gray: #aaaaaa;
            --terminal-dark-gray: #666666;
            --terminal-bg: #000000;
            --terminal-header: #1a1a1a;
            --terminal-content-bg: rgba(0, 0, 0, 0.95);
            --terminal-border: rgba(0, 255, 65, 0.3);
            --terminal-shadow: rgba(0, 255, 65, 0.2);
            --terminal-glow: rgba(0, 255, 65, 0.4);
            
            /* Control colors */
            --control-red: #ff5f56;
            --control-yellow: #ffbd2e;
            --control-green: #27ca42;
            
            /* Responsive spacing */
            --spacing-xs: 0.25rem;
            --spacing-sm: 0.5rem;
            --spacing-md: 1rem;
            --spacing-lg: 1.5rem;
            --spacing-xl: 2rem;
            --spacing-xxl: 3rem;
            
            /* Typography */
            --font-family-mono: 'Fira Code', 'JetBrains Mono', 'Consolas', monospace;
            --font-size-xs: 0.75rem;
            --font-size-sm: 0.875rem;
            --font-size-base: 1rem;
            --font-size-lg: 1.125rem;
            --font-size-xl: 1.25rem;
            --font-size-xxl: 1.5rem;
            
            /* Animations */
            --animation-speed: 0.3s;
            --animation-curve: cubic-bezier(0.4, 0, 0.2, 1);
            
            /* Z-indexes */
            --z-background: -1;
            --z-scanlines: 1;
            --z-terminal: 100;
            --z-active-terminal: 200;
            --z-modal: 1000;
            --z-game: 1001;
        }

        /* CSS Reset & Base Styles */
        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            font-size: 16px;
            scroll-behavior: smooth;
        }

        body {
            font-family: var(--font-family-mono);
            font-weight: 400;
            line-height: 1.5;
            color: var(--terminal-primary);
            background: var(--terminal-bg);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            position: fixed;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            touch-action: manipulation;
        }

        /* Utility Classes */
        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        .no-select {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* Background Effects */
        .bg-project-name {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(2rem, 8vw, 6rem);
            font-weight: 700;
            color: rgba(0, 255, 65, 0.03);
            white-space: nowrap;
            z-index: var(--z-background);
            font-family: var(--font-family-mono);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            transition: color var(--animation-speed) var(--animation-curve);
            cursor: pointer;
            pointer-events: auto;
        }

        .bg-project-name:hover {
            color: rgba(0, 255, 65, 0.08);
        }

        .bg-project-name.bright {
            color: rgba(0, 255, 65, 0.15);
        }

        /* Matrix Rain Background Effect */
        .matrix-rain {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: var(--z-background);
            opacity: 0.1;
            pointer-events: none;
        }

        .matrix-rain canvas {
            display: block;
        }

        /* Scanlines Effect */
        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                transparent 50%,
                rgba(0, 255, 65, 0.03) 50%
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: var(--z-scanlines);
            animation: scanlines 0.1s linear infinite;
        }

        @keyframes scanlines {
            0% { transform: translateY(0); }
            100% { transform: translateY(4px); }
        }

        /* Terminal Container */
        .terminal-container {
            position: absolute;
            min-width: min(90vw, 600px);
            min-height: min(70vh, 400px);
            background: var(--terminal-content-bg);
            border: 1px solid var(--terminal-border);
            border-radius: 12px;
            box-shadow: 
                0 0 0 1px rgba(0, 255, 65, 0.1),
                0 10px 30px var(--terminal-shadow),
                0 0 60px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            z-index: var(--z-terminal);
            transition: all var(--animation-speed) var(--animation-curve);
            will-change: transform;
            contain: layout style paint;
            user-select: none;
        }

        .terminal-container.active {
            z-index: var(--z-active-terminal);
            box-shadow: 
                0 0 0 1px var(--terminal-primary),
                0 15px 60px var(--terminal-glow),
                0 0 100px rgba(0, 0, 0, 0.7);
        }

        .terminal-container.maximized {
            width: 100vw !important;
            height: 100vh !important;
            border-radius: 0 !important;
            top: 0 !important;
            left: 0 !important;
            transform: none !important;
        }

        .terminal-container.minimized {
            transform: scale(0.1);
            opacity: 0;
            pointer-events: none;
        }

        .terminal-container.closing {
            animation: closeTerminal var(--animation-speed) var(--animation-curve) forwards;
        }

        .terminal-container.dragging {
            transition: none !important;
            cursor: grabbing !important;
            transform: scale(1.02);
            box-shadow: 
                0 0 0 1px var(--terminal-primary),
                0 20px 60px var(--terminal-glow),
                0 0 120px rgba(0, 0, 0, 0.8);
        }

        @keyframes closeTerminal {
            to {
                transform: scale(0.8);
                opacity: 0;
            }
        }

        /* Terminal Header */
        .terminal-header {
            background: var(--terminal-header);
            padding: var(--spacing-sm) var(--spacing-md);
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid var(--terminal-border);
            cursor: grab;
            user-select: none;
            min-height: 48px;
        }

        .terminal-header:active {
            cursor: grabbing;
        }

        .terminal-title {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            color: var(--terminal-white);
            font-size: var(--font-size-sm);
            font-weight: 500;
        }

        .terminal-controls {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .control-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            cursor: pointer;
            transition: all var(--animation-speed) var(--animation-curve);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .control-dot::before {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: currentColor;
            opacity: 0;
            transform: scale(0);
            transition: all var(--animation-speed) var(--animation-curve);
        }

        .control-dot:hover::before {
            opacity: 0.2;
            transform: scale(1);
        }

        .control-dot i {
            font-size: 8px;
            color: rgba(0, 0, 0, 0.8);
            opacity: 0;
            transition: opacity var(--animation-speed) var(--animation-curve);
        }

        .control-dot:hover i {
            opacity: 1;
        }

        .red-dot { background: var(--control-red); }
        .yellow-dot { background: var(--control-yellow); }
        .green-dot { background: var(--control-green); }

        /* Terminal Content */
        .terminal-content {
            flex: 1;
            overflow-y: auto;
            padding: var(--spacing-md);
            background: var(--terminal-bg);
            font-family: var(--font-family-mono);
            font-size: var(--font-size-sm);
            line-height: 1.6;
            scrollbar-width: thin;
            scrollbar-color: var(--terminal-primary) transparent;
            user-select: text;
        }

        .terminal-content::-webkit-scrollbar {
            width: 8px;
        }

        .terminal-content::-webkit-scrollbar-track {
            background: transparent;
        }

        .terminal-content::-webkit-scrollbar-thumb {
            background: var(--terminal-primary);
            border-radius: 4px;
            opacity: 0.6;
        }

        .terminal-content::-webkit-scrollbar-thumb:hover {
            opacity: 1;
        }

        /* Terminal Text Elements */
        .command-line {
            display: flex;
            margin-bottom: var(--spacing-sm);
            animation: fadeIn 0.3s ease-out;
        }

        .prompt {
            color: var(--terminal-primary);
            margin-right: var(--spacing-sm);
            white-space: nowrap;
            font-weight: 600;
        }

        .command {
            color: var(--terminal-white);
            flex: 1;
        }

        .response {
            color: var(--terminal-primary);
            margin-bottom: var(--spacing-md);
            white-space: pre-wrap;
            word-wrap: break-word;
            animation: fadeIn 0.3s ease-out;
        }

        .error {
            color: var(--terminal-error);
        }

        .warning {
            color: var(--terminal-warning);
        }

        .success {
            color: var(--terminal-primary);
        }

        .info {
            color: var(--terminal-accent);
        }

        /* Progress Bar */
        .progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(0, 255, 65, 0.1);
            border: 1px solid var(--terminal-primary);
            border-radius: 4px;
            overflow: hidden;
            margin: var(--spacing-sm) 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--terminal-primary), var(--terminal-accent));
            width: 0%;
            transition: width 0.1s ease-out;
            border-radius: 3px;
        }

        /* ASCII Art */
        .ascii-art {
            color: var(--terminal-primary);
            font-family: var(--font-family-mono);
            font-size: var(--font-size-xs);
            line-height: 1.2;
            margin: var(--spacing-lg) 0;
            white-space: pre;
            animation: glitch 2s infinite;
        }

        @keyframes glitch {
            0%, 100% { transform: translate(0); }
            20% { transform: translate(-1px, 1px); }
            40% { transform: translate(-1px, -1px); }
            60% { transform: translate(1px, 1px); }
            80% { transform: translate(1px, -1px); }
        }

        /* Quote Section */
        .quote-section {
            border: 1px solid var(--terminal-border);
            border-radius: 8px;
            padding: var(--spacing-lg);
            margin: var(--spacing-lg) 0;
            background: rgba(0, 255, 65, 0.03);
            backdrop-filter: blur(5px);
            animation: fadeInUp 0.5s ease-out;
        }

        .quote-text {
            color: var(--terminal-white);
            font-size: var(--font-size-lg);
            font-weight: 500;
            margin-bottom: var(--spacing-md);
            line-height: 1.4;
        }

        .quote-author {
            color: var(--terminal-gray);
            text-align: right;
            font-style: italic;
            font-size: var(--font-size-sm);
        }

        /* Buttons */
        .terminal-button {
            background: transparent;
            color: var(--terminal-primary);
            border: 1px solid var(--terminal-primary);
            border-radius: 6px;
            padding: var(--spacing-sm) var(--spacing-md);
            font-family: var(--font-family-mono);
            font-size: var(--font-size-sm);
            cursor: pointer;
            transition: all var(--animation-speed) var(--animation-curve);
            display: inline-flex;
            align-items: center;
            gap: var(--spacing-sm);
            text-decoration: none;
        }

        .terminal-button:hover {
            background: rgba(0, 255, 65, 0.1);
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.3);
            transform: translateY(-2px);
        }

        .terminal-button:active {
            transform: translateY(0);
        }

        .share-container {
            display: flex;
            gap: var(--spacing-sm);
            margin-top: var(--spacing-md);
            flex-wrap: wrap;
        }

        /* Terminal Input */
        .terminal-input-wrapper {
            display: flex;
            align-items: center;
            border-top: 1px solid var(--terminal-border);
            padding: var(--spacing-md);
            background: rgba(0, 255, 65, 0.02);
            min-height: 60px;
        }

        .terminal-input-prompt {
            color: var(--terminal-primary);
            margin-right: var(--spacing-sm);
            white-space: nowrap;
            font-weight: 600;
        }

        .terminal-input {
            flex: 1;
            background: transparent;
            border: none;
            color: var(--terminal-white);
            font-family: var(--font-family-mono);
            font-size: var(--font-size-base);
            outline: none;
            caret-color: var(--terminal-primary);
        }

        .terminal-input::placeholder {
            color: var(--terminal-dark-gray);
        }

        /* Floating Action Button */
        .floating-actions {
            position: fixed;
            bottom: var(--spacing-xl);
            right: var(--spacing-xl);
            display: flex;
            flex-direction: column;
            gap: var(--spacing-md);
            z-index: 500;
        }

        .fab {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: var(--terminal-content-bg);
            color: var(--terminal-primary);
            border: 2px solid var(--terminal-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all var(--animation-speed) var(--animation-curve);
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px var(--terminal-shadow);
        }

        .fab:hover {
            transform: scale(1.1);
            box-shadow: 0 8px 30px var(--terminal-glow);
        }

        .fab i {
            font-size: 24px;
        }

        /* Game Canvas */
        .game-canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--terminal-bg);
            border: 2px solid var(--terminal-primary);
            border-radius: 8px;
            z-index: var(--z-game);
            box-shadow: 0 0 50px var(--terminal-glow);
            display: block;
        }

        .game-canvas.active {
            display: block;
            animation: fadeInScale 0.3s ease-out;
        }

        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        /* Game Overlay */
        .game-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: var(--z-game);
            display: none;
            align-items: center;
            justify-content: center;
        }

        .game-overlay.active {
            display: flex;
        }

        /* Typing Animation */
        .typing-animation {
            overflow: hidden;
            white-space: nowrap;
            animation: typing 2s steps(40, end);
        }

        @keyframes typing {
            from { width: 0; }
            to { width: 100%; }
        }

        .cursor {
            display: inline-block;
            background: var(--terminal-primary);
            width: 2px;
            height: 1em;
            animation: blink 1s infinite;
            margin-left: 2px;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        /* Loading Animation */
        .loading-dots {
            display: inline-flex;
            gap: 2px;
        }

        .loading-dots span {
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background: var(--terminal-primary);
            animation: loadingDots 1.4s infinite ease-in-out both;
        }

        .loading-dots span:nth-child(1) { animation-delay: -0.32s; }
        .loading-dots span:nth-child(2) { animation-delay: -0.16s; }

        @keyframes loadingDots {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1); }
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Resize handles for desktop */
        .resize-handle {
            position: absolute;
            background: transparent;
            z-index: 1000;
            transition: background-color 0.2s ease;
        }

        .resize-handle:hover {
            background: rgba(0, 255, 65, 0.1);
        }

        .resize-handle-n, .resize-handle-s {
            height: 6px;
            left: 6px;
            right: 6px;
        }

        .resize-handle-e, .resize-handle-w {
            width: 6px;
            top: 6px;
            bottom: 6px;
        }

        .resize-handle-n { top: -3px; cursor: n-resize; }
        .resize-handle-s { bottom: -3px; cursor: s-resize; }
        .resize-handle-e { right: -3px; cursor: e-resize; }
        .resize-handle-w { left: -3px; cursor: w-resize; }

        .resize-handle-ne, .resize-handle-nw,
        .resize-handle-se, .resize-handle-sw {
            width: 12px;
            height: 12px;
        }

        .resize-handle-ne { top: -6px; right: -6px; cursor: ne-resize; }
        .resize-handle-nw { top: -6px; left: -6px; cursor: nw-resize; }
        .resize-handle-se { bottom: -6px; right: -6px; cursor: se-resize; }
        .resize-handle-sw { bottom: -6px; left: -6px; cursor: sw-resize; }

        /* Responsive Design */
        @media (max-width: 768px) {
            :root {
                --font-size-base: 0.9rem;
                --font-size-sm: 0.8rem;
                --spacing-md: 0.75rem;
            }

            .terminal-container {
                width: 100vw !important;
                height: 100vh !important;
                min-width: 100vw !important;
                min-height: 100vh !important;
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                border-radius: 0 !important;
                transform: none !important;
            }

            .terminal-header {
                padding: var(--spacing-md);
                min-height: 56px;
            }

            .control-dot {
                width: 18px;
                height: 18px;
            }

            .floating-actions {
                bottom: var(--spacing-lg);
                right: var(--spacing-lg);
            }

            .fab {
                width: 48px;
                height: 48px;
            }

            .fab i {
                font-size: 20px;
            }

            .bg-project-name {
                font-size: clamp(1.5rem, 12vw, 4rem);
            }

            .resize-handle {
                display: none;
            }
        }

        /* Dark mode support */
        @media (prefers-color-scheme: dark) {
            :root {
                --terminal-primary: #00ff41;
                --terminal-bg: #000000;
            }
        }

        /* Reduced motion */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* High contrast mode */
        @media (prefers-contrast: high) {
            :root {
                --terminal-primary: #ffffff;
                --terminal-border: #ffffff;
            }
        }

        /* Performance optimizations */
        .terminal-container {
            transform-style: preserve-3d;
            will-change: transform;
        }

        .terminal-content {
            contain: layout style paint;
            content-visibility: auto;
        }
    </style>
</head>
<body>
    <!-- Matrix Rain Background -->
    <div class="matrix-rain">
        <canvas id="matrixCanvas"></canvas>
    </div>

    <!-- Scanlines Effect -->
    <div class="scanlines"></div>
    
    <!-- Background Project Name -->
    <div class="bg-project-name no-select" id="bgProjectName">NEON ORACLE v3.0</div>
    
    <!-- Floating Action Buttons -->
    <div class="floating-actions">
        <button class="fab" id="newTerminalBtn" title="New Terminal" aria-label="Create new terminal">
            <i class="ph ph-terminal"></i>
        </button>
        <button class="fab" id="gameMenuBtn" title="Games" aria-label="Open games menu">
            <i class="ph ph-game-controller"></i>
        </button>
    </div>

    <!-- Game Overlay -->
    <div class="game-overlay" id="gameOverlay">
        <canvas class="game-canvas" id="gameCanvas" width="400" height="400"></canvas>
    </div>
    
    <!-- Terminal Template -->
    <template id="terminalTemplate">
        <div class="terminal-container">
            <div class="terminal-header">
                <div class="terminal-title">
                    <i class="ph ph-terminal"></i>
                    <span class="terminal-path">user@neon-oracle: ~/</span>
                </div>
                <div class="terminal-controls">
                    <div class="control-dot red-dot" title="Close" aria-label="Close terminal">
                        <i class="ph ph-x"></i>
                    </div>
                    <div class="control-dot yellow-dot" title="Minimize" aria-label="Minimize terminal">
                        <i class="ph ph-minus"></i>
                    </div>
                    <div class="control-dot green-dot" title="Maximize" aria-label="Maximize terminal">
                        <i class="ph ph-square"></i>
                    </div>
                </div>
            </div>
            
            <div class="terminal-content"></div>
            
            <div class="terminal-input-wrapper">
                <div class="terminal-input-prompt">user@neon-oracle:~$</div>
                <input type="text" class="terminal-input" placeholder="Type 'help' for commands" autocomplete="off" spellcheck="false">
            </div>
            
            <!-- Resize handles (desktop only) -->
            <div class="resize-handle resize-handle-n"></div>
            <div class="resize-handle resize-handle-e"></div>
            <div class="resize-handle resize-handle-s"></div>
            <div class="resize-handle resize-handle-w"></div>
            <div class="resize-handle resize-handle-ne"></div>
            <div class="resize-handle resize-handle-se"></div>
            <div class="resize-handle resize-handle-sw"></div>
            <div class="resize-handle resize-handle-nw"></div>
        </div>
    </template>
    
    <script>
        // Modern JavaScript with ES6+ features
        class NeonOracle {
            constructor() {
                this.terminals = new Map();
                this.activeTerminal = null;
                this.zIndexCounter = 100;
                this.gameInstance = null;
                this.quotes = null;
                this.matrixRain = null;
                this.isDragging = false;
                this.isResizing = false;
                
                this.init();
            }

            async init() {
                console.log('%c🚀 NEON ORACLE v3.0 INITIALIZED', 'color: #00ff41; font-size: 16px; font-weight: bold;');
                
                // Initialize matrix rain effect
                this.initMatrixRain();
                
                // Load quotes from GitHub
                await this.loadQuotes();
                
                // Setup event listeners
                this.setupEventListeners();
                
                // Create initial terminal
                this.createTerminal();
                
                // Register service worker for PWA
                this.registerServiceWorker();
            }

            // Matrix Rain Effect - FIXED SPEED
            initMatrixRain() {
                const canvas = document.getElementById('matrixCanvas');
                const ctx = canvas.getContext('2d');
                let animationId;
                let lastFrameTime = 0;
                const frameDelay = 33; // 30fps - perfect speed
                
                const resizeCanvas = () => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                    this.setupMatrixDrops();
                };
                
                this.setupMatrixDrops = () => {
                    const fontSize = 14;
                    const columns = Math.floor(canvas.width / fontSize);
                    this.matrixDrops = [];
                    
                    for (let x = 0; x < columns; x++) {
                        this.matrixDrops[x] = Math.random() * canvas.height / fontSize;
                    }
                };
                
                resizeCanvas();
                
                // Simple resize handler
                window.addEventListener('resize', () => {
                    requestAnimationFrame(resizeCanvas);
                });
                
                const chars = 'アァカサタナハマヤャラワガザダバパイィキシチニヒミリヰギジヂビピウゥクスツヌフムユュルグズヅブプエェケセテネヘメレヱゲゼデベペオォコソトノホモヨョロヲゴゾドボポヴッン0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                const charArray = chars.split('');
                const fontSize = 14;
                
                const draw = (currentTime) => {
                    if (currentTime - lastFrameTime < frameDelay) {
                        animationId = requestAnimationFrame(draw);
                        return;
                    }
                    
                    lastFrameTime = currentTime;
                    
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.fillStyle = '#00ff41';
                    ctx.font = fontSize + 'px Fira Code';
                    
                    if (this.matrixDrops) {
                        for (let i = 0; i < this.matrixDrops.length; i++) {
                            const text = charArray[Math.floor(Math.random() * charArray.length)];
                            ctx.fillText(text, i * fontSize, this.matrixDrops[i] * fontSize);
                            
                            if (this.matrixDrops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                                this.matrixDrops[i] = 0;
                            }
                            this.matrixDrops[i]++;
                        }
                    }
                    
                    animationId = requestAnimationFrame(draw);
                };
                
                draw(0);
                this.matrixAnimationId = animationId;
            }

            // Load quotes from GitHub
            async loadQuotes() {
                try {
                    console.log('Fetching quotes from GitHub...');
                    const response = await fetch('https://raw.githubusercontent.com/Saganaki22/NeonOracle/refs/heads/main/quotes.json');
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    this.quotes = await response.json();
                    console.log('✅ Quotes loaded successfully from GitHub!', this.quotes);
                    return true;
                } catch (error) {
                    console.error('❌ Failed to load quotes from GitHub:', error);
                    
                    // Fallback quotes
                    this.quotes = {
                        categories: {
                            "Inspiration": [
                                { text: "The future belongs to those who believe in the beauty of their dreams.", author: "Eleanor Roosevelt" },
                                { text: "Code is poetry written in logic.", author: "Anonymous" },
                                { text: "In the world of algorithms, elegance is efficiency.", author: "Modern Oracle" }
                            ],
                            "Technology": [
                                { text: "Any sufficiently advanced technology is indistinguishable from magic.", author: "Arthur C. Clarke" },
                                { text: "The best way to predict the future is to create it.", author: "Peter Drucker" },
                                { text: "Programs must be written for people to read, and only incidentally for machines to execute.", author: "Harold Abelson" }
                            ],
                            "Philosophy": [
                                { text: "The only way to make sense out of change is to plunge into it, move with it, and join the dance.", author: "Alan Watts" },
                                { text: "We are what we repeatedly do. Excellence, then, is not an act, but a habit.", author: "Aristotle" },
                                { text: "The cave you fear to enter holds the treasure you seek.", author: "Joseph Campbell" }
                            ]
                        }
                    };
                    return false;
                }
            }

            // Get random quote
            getRandomQuote() {
                if (!this.quotes) return null;
                
                const categories = Object.keys(this.quotes.categories);
                const randomCategory = categories[Math.floor(Math.random() * categories.length)];
                const quotes = this.quotes.categories[randomCategory];
                
                return quotes[Math.floor(Math.random() * quotes.length)];
            }

            // Setup event listeners
            setupEventListeners() {
                const newTerminalBtn = document.getElementById('newTerminalBtn');
                const gameMenuBtn = document.getElementById('gameMenuBtn');
                const bgProjectName = document.getElementById('bgProjectName');
                const gameOverlay = document.getElementById('gameOverlay');
                
                newTerminalBtn.addEventListener('click', () => this.createTerminal());
                gameMenuBtn.addEventListener('click', () => this.showGameMenu());
                
                // Background click handler
                bgProjectName.addEventListener('click', (e) => {
                    if (!this.isOverTerminal(e)) {
                        window.open('https://github.com/saganaki22/neonoracle', '_blank');
                    }
                });

                // Close game overlay when clicked outside
                gameOverlay.addEventListener('click', (e) => {
                    if (e.target === gameOverlay) {
                        this.closeGame();
                    }
                });

                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        switch (e.key) {
                            case 't':
                                e.preventDefault();
                                this.createTerminal();
                                break;
                            case 'w':
                                e.preventDefault();
                                if (this.activeTerminal) {
                                    this.closeTerminal(this.activeTerminal);
                                }
                                break;
                        }
                    }
                    
                    // Close game on escape
                    if (e.key === 'Escape' && this.gameInstance) {
                        this.closeGame();
                    }
                });

                // Simple resize handler
                window.addEventListener('resize', () => {
                    this.handleResize();
                });
            }

            // Utility: Simple debounce function
            debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }

            // Check if mouse is over terminal
            isOverTerminal(event) {
                const terminals = document.querySelectorAll('.terminal-container');
                for (const terminal of terminals) {
                    const rect = terminal.getBoundingClientRect();
                    if (event.clientX >= rect.left && event.clientX <= rect.right &&
                        event.clientY >= rect.top && event.clientY <= rect.bottom) {
                        return true;
                    }
                }
                return false;
            }

            // Handle window resize - SIMPLIFIED
            handleResize() {
                const isMobile = window.innerWidth <= 768;
                
                this.terminals.forEach(terminal => {
                    if (isMobile) {
                        terminal.style.width = '100vw';
                        terminal.style.height = '100vh';
                        terminal.style.top = '0';
                        terminal.style.left = '0';
                    }
                });
            }

            // Create terminal
            createTerminal() {
                const template = document.getElementById('terminalTemplate');
                const terminalElement = template.content.cloneNode(true).querySelector('.terminal-container');
                const terminalId = `terminal-${Date.now()}`;
                
                terminalElement.id = terminalId;
                
                // Position terminal
                const isMobile = window.innerWidth <= 768;
                if (!isMobile) {
                    const offset = this.terminals.size * 30;
                    terminalElement.style.left = `${Math.min(offset + 50, window.innerWidth - 650)}px`;
                    terminalElement.style.top = `${Math.min(offset + 50, window.innerHeight - 450)}px`;
                    terminalElement.style.width = '60vw';
                    terminalElement.style.height = '70vh';
                }
                
                document.body.appendChild(terminalElement);
                
                // Store terminal reference
                this.terminals.set(terminalId, terminalElement);
                
                // Setup terminal
                this.setupTerminalControls(terminalElement);
                this.setupTerminalDrag(terminalElement);
                this.setupTerminalResize(terminalElement);
                this.setupTerminalInput(terminalElement);
                this.setActiveTerminal(terminalElement);
                
                // Initialize terminal content
                this.initTerminalContent(terminalElement);
                
                return terminalElement;
            }

            // Setup terminal controls
            setupTerminalControls(terminal) {
                const controls = terminal.querySelector('.terminal-controls');
                const redDot = controls.querySelector('.red-dot');
                const yellowDot = controls.querySelector('.yellow-dot');
                const greenDot = controls.querySelector('.green-dot');
                
                redDot.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.closeTerminal(terminal);
                });
                
                yellowDot.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.minimizeTerminal(terminal);
                });
                
                greenDot.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.toggleMaximizeTerminal(terminal);
                });
                
                // Click to focus
                terminal.addEventListener('click', () => {
                    this.setActiveTerminal(terminal);
                });
            }

            // Close terminal
            closeTerminal(terminal) {
                terminal.classList.add('closing');
                
                // Clean up drag events
                if (terminal._dragCleanup) {
                    terminal._dragCleanup();
                }
                
                setTimeout(() => {
                    terminal.remove();
                    this.terminals.delete(terminal.id);
                    
                    // Set focus to another terminal if available
                    if (this.activeTerminal === terminal) {
                        const remainingTerminals = Array.from(this.terminals.values());
                        if (remainingTerminals.length > 0) {
                            this.setActiveTerminal(remainingTerminals[0]);
                        } else {
                            this.activeTerminal = null;
                        }
                    }
                }, 300);
            }

            // Minimize terminal
            minimizeTerminal(terminal) {
                terminal.classList.add('minimized');
                setTimeout(() => {
                    terminal.style.display = 'none';
                    terminal.classList.remove('minimized');
                }, 300);
            }

            // Toggle maximize terminal
            toggleMaximizeTerminal(terminal) {
                const isMaximized = terminal.classList.contains('maximized');
                const greenDot = terminal.querySelector('.green-dot i');
                
                if (isMaximized) {
                    terminal.classList.remove('maximized');
                    greenDot.className = 'ph ph-square';
                } else {
                    terminal.classList.add('maximized');
                    greenDot.className = 'ph ph-corners-out';
                }
            }

            // Set active terminal
            setActiveTerminal(terminal) {
                // Remove active class from all terminals
                this.terminals.forEach(t => t.classList.remove('active'));
                
                // Set active
                terminal.classList.add('active');
                this.activeTerminal = terminal;
                
                // Bring to front
                terminal.style.zIndex = ++this.zIndexCounter;
                
                // Focus input
                const input = terminal.querySelector('.terminal-input');
                input?.focus();
            }

            // Setup terminal drag (desktop only) - FIXED DRAGGING
            setupTerminalDrag(terminal) {
                if (window.innerWidth <= 768) return;
                
                const header = terminal.querySelector('.terminal-header');
                let isDragging = false;
                let dragData = null;
                
                const onMouseDown = (e) => {
                    if (e.target.closest('.terminal-controls')) return;
                    if (isDragging) return; // Prevent multiple drags
                    
                    isDragging = true;
                    this.isDragging = true;
                    
                    dragData = {
                        startX: e.clientX,
                        startY: e.clientY,
                        startLeft: terminal.offsetLeft,
                        startTop: terminal.offsetTop,
                        terminal: terminal
                    };
                    
                    terminal.classList.add('dragging');
                    this.setActiveTerminal(terminal);
                    
                    e.preventDefault();
                    e.stopPropagation();
                };
                
                const onMouseMove = (e) => {
                    if (!isDragging || !dragData || dragData.terminal !== terminal) return;
                    
                    const deltaX = e.clientX - dragData.startX;
                    const deltaY = e.clientY - dragData.startY;
                    
                    const newLeft = Math.max(0, Math.min(window.innerWidth - terminal.offsetWidth, dragData.startLeft + deltaX));
                    const newTop = Math.max(0, Math.min(window.innerHeight - terminal.offsetHeight, dragData.startTop + deltaY));
                    
                    terminal.style.left = `${newLeft}px`;
                    terminal.style.top = `${newTop}px`;
                    
                    e.preventDefault();
                    e.stopPropagation();
                };
                
                const onMouseUp = (e) => {
                    if (!isDragging) return;
                    
                    isDragging = false;
                    this.isDragging = false;
                    dragData = null;
                    terminal.classList.remove('dragging');
                    
                    e.preventDefault();
                    e.stopPropagation();
                };
                
                // Bind events specifically to this terminal
                header.addEventListener('mousedown', onMouseDown);
                
                // Store cleanup function
                terminal._dragCleanup = () => {
                    header.removeEventListener('mousedown', onMouseDown);
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                };
                
                // Global move and up events
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            }

            // Setup terminal resize (desktop only)
            setupTerminalResize(terminal) {
                if (window.innerWidth <= 768) return;
                
                const handles = terminal.querySelectorAll('.resize-handle');
                let resizeData = null;
                
                const minWidth = 400;
                const minHeight = 300;
                
                handles.forEach(handle => {
                    handle.addEventListener('mousedown', (e) => {
                        this.isResizing = true;
                        resizeData = {
                            handle: handle,
                            startX: e.clientX,
                            startY: e.clientY,
                            startWidth: terminal.offsetWidth,
                            startHeight: terminal.offsetHeight,
                            startLeft: terminal.offsetLeft,
                            startTop: terminal.offsetTop
                        };
                        
                        e.preventDefault();
                        e.stopPropagation();
                    });
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (!this.isResizing || !resizeData) return;
                    
                    const deltaX = e.clientX - resizeData.startX;
                    const deltaY = e.clientY - resizeData.startY;
                    const handleClass = resizeData.handle.className;
                    
                    let newWidth = resizeData.startWidth;
                    let newHeight = resizeData.startHeight;
                    let newLeft = resizeData.startLeft;
                    let newTop = resizeData.startTop;
                    
                    if (handleClass.includes('se')) {
                        newWidth = Math.max(minWidth, resizeData.startWidth + deltaX);
                        newHeight = Math.max(minHeight, resizeData.startHeight + deltaY);
                    } else if (handleClass.includes('sw')) {
                        newWidth = Math.max(minWidth, resizeData.startWidth - deltaX);
                        newHeight = Math.max(minHeight, resizeData.startHeight + deltaY);
                        newLeft = resizeData.startLeft + (resizeData.startWidth - newWidth);
                    } else if (handleClass.includes('ne')) {
                        newWidth = Math.max(minWidth, resizeData.startWidth + deltaX);
                        newHeight = Math.max(minHeight, resizeData.startHeight - deltaY);
                        newTop = resizeData.startTop + (resizeData.startHeight - newHeight);
                    } else if (handleClass.includes('nw')) {
                        newWidth = Math.max(minWidth, resizeData.startWidth - deltaX);
                        newHeight = Math.max(minHeight, resizeData.startHeight - deltaY);
                        newLeft = resizeData.startLeft + (resizeData.startWidth - newWidth);
                        newTop = resizeData.startTop + (resizeData.startHeight - newHeight);
                    } else if (handleClass.includes('e')) {
                        newWidth = Math.max(minWidth, resizeData.startWidth + deltaX);
                    } else if (handleClass.includes('w')) {
                        newWidth = Math.max(minWidth, resizeData.startWidth - deltaX);
                        newLeft = resizeData.startLeft + (resizeData.startWidth - newWidth);
                    } else if (handleClass.includes('s')) {
                        newHeight = Math.max(minHeight, resizeData.startHeight + deltaY);
                    } else if (handleClass.includes('n')) {
                        newHeight = Math.max(minHeight, resizeData.startHeight - deltaY);
                        newTop = resizeData.startTop + (resizeData.startHeight - newHeight);
                    }
                    
                    requestAnimationFrame(() => {
                        terminal.style.width = `${newWidth}px`;
                        terminal.style.height = `${newHeight}px`;
                        terminal.style.left = `${newLeft}px`;
                        terminal.style.top = `${newTop}px`;
                    });
                });
                
                document.addEventListener('mouseup', () => {
                    if (!this.isResizing) return;
                    
                    this.isResizing = false;
                    resizeData = null;
                });
            }

            // Setup terminal input
            setupTerminalInput(terminal) {
                const input = terminal.querySelector('.terminal-input');
                const content = terminal.querySelector('.terminal-content');
                
                // Placeholder rotation
                const placeholders = [
                    'help - show available commands',
                    'quote - get inspirational quote',
                    'games - play retro games',
                    'matrix - toggle matrix rain',
                    'clear - clear terminal',
                    'whoami - system information'
                ];
                
                let placeholderIndex = 0;
                const rotatePlaceholder = () => {
                    input.placeholder = placeholders[placeholderIndex];
                    placeholderIndex = (placeholderIndex + 1) % placeholders.length;
                };
                
                rotatePlaceholder();
                const placeholderInterval = setInterval(rotatePlaceholder, 3000);
                
                // Command handling
                input.addEventListener('keydown', async (e) => {
                    if (e.key === 'Enter') {
                        const command = input.value.trim();
                        input.value = '';
                        
                        if (command) {
                            this.addCommandLine(content, command);
                            await this.executeCommand(command, content, terminal);
                        }
                    }
                });
                
                // Clean up interval when terminal is closed
                terminal.addEventListener('beforeunload', () => {
                    clearInterval(placeholderInterval);
                });
            }

            // Add command line to terminal
            addCommandLine(content, command) {
                const commandLine = document.createElement('div');
                commandLine.className = 'command-line';
                commandLine.innerHTML = `
                    <span class="prompt">user@neon-oracle:~$</span>
                    <span class="command">${this.escapeHtml(command)}</span>
                `;
                content.appendChild(commandLine);
                this.scrollToBottom(content);
            }

            // Add response to terminal
            addResponse(content, text, className = 'response') {
                const response = document.createElement('div');
                response.className = className;
                response.innerHTML = text;
                content.appendChild(response);
                this.scrollToBottom(content);
                return response;
            }

            // Scroll to bottom
            scrollToBottom(content) {
                requestAnimationFrame(() => {
                    content.scrollTop = content.scrollHeight;
                });
            }

            // Escape HTML
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            // Execute command
            async executeCommand(command, content, terminal) {
                const cmd = command.toLowerCase();
                
                switch (cmd) {
                    case 'help':
                        this.showHelp(content);
                        break;
                    case 'quote':
                        await this.showQuote(content);
                        break;
                    case 'games':
                        this.showGameMenu();
                        break;
                    case 'snake':
                        this.startGame('snake');
                        break;
                    case 'tetris':
                        this.startGame('tetris');
                        break;
                    case 'pong':
                        this.startGame('pong');
                        break;
                    case 'matrix':
                        this.toggleMatrix(content);
                        break;
                    case 'clear':
                        content.innerHTML = '';
                        break;
                    case 'whoami':
                        this.showSystemInfo(content);
                        break;
                    case 'exit':
                    case 'quit':
                        this.closeTerminal(terminal);
                        break;
                    case 'hack':
                        await this.runHackSequence(content);
                        break;
                    case 'love':
                        await this.showLove(content);
                        break;
                    case 'neofetch':
                        this.showNeofetch(content);
                        break;
                    default:
                        this.addResponse(content, `Command not found: ${command}`, 'response error');
                        this.addResponse(content, "Type 'help' for available commands.", 'response');
                }
            }

            // Show help
            showHelp(content) {
                const helpText = `
<span class="success">Available Commands:</span>

<span class="info">System Commands:</span>
  help      - Show this help message
  clear     - Clear terminal screen
  exit      - Close terminal
  whoami    - Show system information
  neofetch  - Display system info with ASCII art

<span class="info">Content Commands:</span>
  quote     - Get inspirational quote
  matrix    - Toggle matrix rain effect

<span class="info">Games & Entertainment:</span>
  games     - Open games menu
  snake     - Play Snake game
  tetris    - Play Tetris
  pong      - Play Pong

<span class="info">Easter Eggs:</span>
  hack      - Run hacking simulation
  love      - Show some love ❤️

<span class="warning">Tip:</span> Use Ctrl+T for new terminal, Ctrl+W to close current terminal
                `;
                this.addResponse(content, helpText);
            }

            // Show quote
            async showQuote(content) {
                const loadingResponse = this.addResponse(content, 'Fetching wisdom from the Oracle <span class="loading-dots"><span></span><span></span><span></span></span>');
                
                // Simulate loading delay
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                const quote = this.getRandomQuote();
                if (quote) {
                    loadingResponse.remove();
                    
                    const quoteSection = document.createElement('div');
                    quoteSection.className = 'quote-section';
                    quoteSection.innerHTML = `
                        <div class="quote-text">"${quote.text}"</div>
                        <div class="quote-author">— ${quote.author}</div>
                        <div class="share-container">
                            <button class="terminal-button" onclick="navigator.clipboard.writeText('${quote.text} — ${quote.author}')">
                                <i class="ph ph-copy"></i> Copy
                            </button>
                            <button class="terminal-button" onclick="window.open('https://twitter.com/intent/tweet?text=${encodeURIComponent(quote.text + ' — ' + quote.author)}', '_blank')">
                                <i class="ph ph-twitter-logo"></i> Tweet
                            </button>
                        </div>
                    `;
                    content.appendChild(quoteSection);
                } else {
                    loadingResponse.innerHTML = '<span class="error">Failed to fetch quote. Try again later.</span>';
                }
                
                this.scrollToBottom(content);
            }

            // Show system info
            showSystemInfo(content) {
                const info = `
<span class="success">System Information:</span>
User: neon-oracle-user
OS: Neon Oracle Linux v3.0
Kernel: 6.1.0-neon
Shell: /bin/neon-bash
Terminal: Neon Terminal Emulator
Uptime: ${this.getUptime()}
Memory: ${this.getMemoryInfo()}
CPU: Quantum Processing Unit
Network: Connected to the Matrix
                `;
                this.addResponse(content, info);
            }

            // Show neofetch
            showNeofetch(content) {
                const asciiArt = `
    <pre class="ascii-art">
        ████████╗ ██████╗ ██████╗  █████╗  ██████╗██╗     ███████╗
        ╚══██╔══╝██╔═══██╗██╔══██╗██╔══██╗██╔════╝██║     ██╔════╝
           ██║   ██║   ██║██████╔╝███████║██║     ██║     █████╗  
           ██║   ██║   ██║██╔══██╗██╔══██║██║     ██║     ██╔══╝  
           ██║   ╚██████╔╝██║  ██║██║  ██║╚██████╗███████╗███████╗
           ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝╚══════╝╚══════╝
    </pre>
                `;
                
                const systemInfo = `
<span class="info">OS:</span> Neon Oracle Linux v3.0
<span class="info">Host:</span> Quantum Mainframe
<span class="info">Kernel:</span> 6.1.0-neon-oracle
<span class="info">Uptime:</span> ${this.getUptime()}
<span class="info">Shell:</span> neon-bash 5.1.16
<span class="info">Terminal:</span> Neon Terminal Emulator
<span class="info">CPU:</span> Quantum Processing Unit (8 cores)
<span class="info">GPU:</span> Neural Graphics Processor
<span class="info">Memory:</span> ${this.getMemoryInfo()}
                `;
                
                this.addResponse(content, asciiArt + systemInfo);
            }

            // Get uptime
            getUptime() {
                const start = performance.now();
                const seconds = Math.floor(start / 1000);
                const minutes = Math.floor(seconds / 60);
                const hours = Math.floor(minutes / 60);
                return `${hours}h ${minutes % 60}m ${seconds % 60}s`;
            }

            // Get memory info
            getMemoryInfo() {
                if (navigator.deviceMemory) {
                    return `${navigator.deviceMemory}GB`;
                }
                return '8GB (estimated)';
            }

            // Toggle matrix rain
            toggleMatrix(content) {
                const matrixRain = document.querySelector('.matrix-rain');
                const isVisible = matrixRain.style.opacity !== '0';
                
                if (isVisible) {
                    matrixRain.style.opacity = '0';
                    this.addResponse(content, '<span class="success">Matrix rain disabled</span>');
                } else {
                    matrixRain.style.opacity = '0.1';
                    this.addResponse(content, '<span class="success">Matrix rain enabled</span>');
                }
            }

            // Run hack sequence - Enhanced with progress bar
            async runHackSequence(content) {
                const hackMessages = [
                    'Initializing hack sequence...',
                    'Bypassing firewall protocols...',
                    'Scanning network vulnerabilities...',
                    'Injecting payload into mainframe...',
                    'Cracking 256-bit encryption...',
                    'Accessing secure databases...',
                    'Extracting classified files...',
                    'Installing backdoor access...',
                    'Erasing digital footprints...',
                    'Laundering through proxy chains...',
                    'Final system penetration...',
                    'Mission accomplished! 🎯'
                ];
                
                // Create progress bar
                const progressContainer = document.createElement('div');
                progressContainer.innerHTML = `
                    <div class="progress-bar">
                        <div class="progress-fill" id="hackProgress"></div>
                    </div>
                `;
                content.appendChild(progressContainer);
                
                const progressBar = progressContainer.querySelector('#hackProgress');
                
                for (let i = 0; i < hackMessages.length; i++) {
                    const message = hackMessages[i];
                    const isLast = i === hackMessages.length - 1;
                    const className = isLast ? 'response success' : 'response';
                    
                    this.addResponse(content, message, className);
                    
                    // Update progress bar
                    const progress = ((i + 1) / hackMessages.length) * 100;
                    progressBar.style.width = `${progress}%`;
                    
                    await new Promise(resolve => setTimeout(resolve, 600));
                }
                
                // Remove progress bar and redirect - FIXED
                setTimeout(() => {
                    progressContainer.remove();
                    this.addResponse(content, '<span class="success">Opening secure terminal...</span>');
                    setTimeout(() => {
                        window.open('https://www.youtube.com/watch?v=qbWqXKN3m3c', '_blank');
                    }, 1000);
                }, 500);
            }

            // Show love - Enhanced with redirect
            async showLove(content) {
                const loveText = `
<span style="color: #ff69b4;">
   ❤️  ❤️  ❤️  ❤️  ❤️  ❤️  ❤️  ❤️  ❤️
  ❤️  Made with love by the Oracle  ❤️
   ❤️  ❤️  ❤️  ❤️  ❤️  ❤️  ❤️  ❤️  ❤️
</span>

<span class="success">Loading special message...</span>
                `;
                this.addResponse(content, loveText);
                
                // Wait and redirect
                setTimeout(() => {
                    this.addResponse(content, '<span class="info">Redirecting to a special message from the Oracle... 💝</span>');
                    setTimeout(() => {
                        window.open('https://www.youtube.com/watch?v=tb4ozEOZh8U', '_blank');
                    }, 2000);
                }, 1500);
            }

            // Initialize terminal content
            async initTerminalContent(terminal) {
                const content = terminal.querySelector('.terminal-content');
                
                // Welcome message
                const welcomeArt = `
    <pre class="ascii-art">
    ███╗   ██╗███████╗ ██████╗ ███╗   ██╗
    ████╗  ██║██╔════╝██╔═══██╗████╗  ██║
    ██╔██╗ ██║█████╗  ██║   ██║██╔██╗ ██║
    ██║╚██╗██║██╔══╝  ██║   ██║██║╚██╗██║
    ██║ ╚████║███████╗╚██████╔╝██║ ╚████║
    ╚═╝  ╚═══╝╚══════╝ ╚═════╝ ╚═╝  ╚═══╝
                      
     ██████╗ ██████╗  █████╗  ██████╗██╗     ███████╗
    ██╔═══██╗██╔══██╗██╔══██╗██╔════╝██║     ██╔════╝
    ██║   ██║██████╔╝███████║██║     ██║     █████╗  
    ██║   ██║██╔══██╗██╔══██║██║     ██║     ██╔══╝  
    ╚██████╔╝██║  ██║██║  ██║╚██████╗███████╗███████╗
     ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝╚══════╝╚══════╝
                      
                      v3.0 - Modern Edition
    </pre>
                `;
                
                this.addResponse(content, welcomeArt);
                this.addResponse(content, '<span class="success">Welcome to Neon Oracle v3.0 - Modern Edition</span>');
                this.addResponse(content, '<span class="info">Now loading quotes from GitHub repository!</span>');
                this.addResponse(content, "Type 'help' to see available commands or 'quote' for wisdom.");
                
                // Auto-fetch first quote
                setTimeout(() => {
                    this.executeCommand('quote', content, terminal);
                }, 1000);
            }

            // Show game menu
            showGameMenu() {
                if (this.activeTerminal) {
                    const content = this.activeTerminal.querySelector('.terminal-content');
                    const gameMenu = `
<span class="success">🎮 Game Menu</span>

Available Games:
  <span class="info">snake</span>  - Classic Snake game
  <span class="info">tetris</span> - Block puzzle game
  <span class="info">pong</span>   - Retro ping pong

Type the game name to start playing!
                    `;
                    this.addResponse(content, gameMenu);
                }
            }

            // Start game - FIXED
            startGame(gameName) {
                const gameOverlay = document.getElementById('gameOverlay');
                const canvas = document.getElementById('gameCanvas');
                const ctx = canvas.getContext('2d');
                
                // Clear previous game
                if (this.gameInstance) {
                    this.gameInstance.stop();
                    this.gameInstance = null;
                }
                
                // Reset canvas size
                canvas.width = 400;
                canvas.height = 400;
                
                // Show game overlay and canvas
                gameOverlay.classList.add('active');
                canvas.classList.add('active');
                
                // Clear canvas
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Small delay to ensure DOM is updated
                setTimeout(() => {
                    // Create game instance
                    switch (gameName) {
                        case 'snake':
                            this.gameInstance = new SnakeGame(ctx, canvas);
                            break;
                        case 'tetris':
                            this.gameInstance = new TetrisGame(ctx, canvas);
                            break;
                        case 'pong':
                            this.gameInstance = new PongGame(ctx, canvas);
                            break;
                    }
                }, 50);
            }

            // Close game
            closeGame() {
                const gameOverlay = document.getElementById('gameOverlay');
                const canvas = document.getElementById('gameCanvas');
                
                gameOverlay.classList.remove('active');
                canvas.classList.remove('active');
                
                if (this.gameInstance) {
                    this.gameInstance.stop();
                    this.gameInstance = null;
                }
                
                // Clear canvas
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // Register service worker for PWA
            async registerServiceWorker() {
                if ('serviceWorker' in navigator) {
                    try {
                        const registration = await navigator.serviceWorker.register('/sw.js');
                        console.log('ServiceWorker registered:', registration);
                    } catch (error) {
                        console.log('ServiceWorker registration failed:', error);
                    }
                }
            }
        }

        // Snake Game Class - FIXED AND IMPROVED
        class SnakeGame {
            constructor(ctx, canvas) {
                this.ctx = ctx;
                this.canvas = canvas;
                this.gridSize = 20;
                this.snake = [{ x: 200, y: 200 }];
                this.food = this.generateFood();
                this.direction = { x: 0, y: 0 };
                this.score = 0;
                this.gameRunning = true;
                this.lastTime = 0;
                this.gameSpeed = 150; // milliseconds
                
                console.log('Snake game initialized');
                this.bindEvents();
                
                // Start the game loop
                requestAnimationFrame((time) => this.gameLoop(time));
            }
            
            generateFood() {
                let newFood;
                do {
                    newFood = {
                        x: Math.floor(Math.random() * (this.canvas.width / this.gridSize)) * this.gridSize,
                        y: Math.floor(Math.random() * (this.canvas.height / this.gridSize)) * this.gridSize
                    };
                } while (this.snake.some(segment => segment.x === newFood.x && segment.y === newFood.y));
                
                return newFood;
            }
            
            bindEvents() {
                this.keyHandler = (e) => {
                    if (!this.gameRunning) return;
                    
                    e.preventDefault();
                    switch (e.key) {
                        case 'ArrowUp':
                        case 'w':
                        case 'W':
                            if (this.direction.y === 0) this.direction = { x: 0, y: -this.gridSize };
                            break;
                        case 'ArrowDown':
                        case 's':
                        case 'S':
                            if (this.direction.y === 0) this.direction = { x: 0, y: this.gridSize };
                            break;
                        case 'ArrowLeft':
                        case 'a':
                        case 'A':
                            if (this.direction.x === 0) this.direction = { x: -this.gridSize, y: 0 };
                            break;
                        case 'ArrowRight':
                        case 'd':
                        case 'D':
                            if (this.direction.x === 0) this.direction = { x: this.gridSize, y: 0 };
                            break;
                    }
                };
                document.addEventListener('keydown', this.keyHandler);
            }
            
            gameLoop(currentTime) {
                if (!this.gameRunning) return;
                
                if (currentTime - this.lastTime >= this.gameSpeed) {
                    this.update();
                    this.lastTime = currentTime;
                }
                
                this.draw();
                requestAnimationFrame((time) => this.gameLoop(time));
            }
            
            update() {
                if (this.direction.x === 0 && this.direction.y === 0) return;
                
                const head = { x: this.snake[0].x + this.direction.x, y: this.snake[0].y + this.direction.y };
                
                // Check collision with walls
                if (head.x < 0 || head.x >= this.canvas.width || head.y < 0 || head.y >= this.canvas.height) {
                    this.gameOver();
                    return;
                }
                
                // Check collision with self
                if (this.snake.some(segment => segment.x === head.x && segment.y === head.y)) {
                    this.gameOver();
                    return;
                }
                
                this.snake.unshift(head);
                
                // Check food collision
                if (head.x === this.food.x && head.y === this.food.y) {
                    this.score += 10;
                    this.food = this.generateFood();
                    // Increase speed slightly
                    this.gameSpeed = Math.max(80, this.gameSpeed - 2);
                } else {
                    this.snake.pop();
                }
            }
            
            draw() {
                // Clear canvas
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw snake
                this.ctx.fillStyle = '#00ff41';
                this.snake.forEach((segment, index) => {
                    if (index === 0) {
                        // Head is brighter
                        this.ctx.fillStyle = '#00ff41';
                    } else {
                        this.ctx.fillStyle = '#008f11';
                    }
                    this.ctx.fillRect(segment.x + 1, segment.y + 1, this.gridSize - 2, this.gridSize - 2);
                    this.ctx.fillStyle = '#00ff41';
                });
                
                // Draw food
                this.ctx.fillStyle = '#ff0080';
                this.ctx.fillRect(this.food.x + 1, this.food.y + 1, this.gridSize - 2, this.gridSize - 2);
                
                // Draw score and instructions
                this.ctx.fillStyle = '#fff';
                this.ctx.font = '16px Fira Code';
                this.ctx.fillText(`Score: ${this.score}`, 10, 30);
                this.ctx.fillText('Use WASD or arrow keys', 10, 50);
                this.ctx.fillText('Press ESC to exit', 10, 70);
            }
            
            gameOver() {
                this.gameRunning = false;
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.fillStyle = '#ff0080';
                this.ctx.font = '24px Fira Code';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Game Over!', this.canvas.width / 2, this.canvas.height / 2 - 20);
                this.ctx.fillText(`Final Score: ${this.score}`, this.canvas.width / 2, this.canvas.height / 2 + 10);
                this.ctx.fillText('Press ESC to close', this.canvas.width / 2, this.canvas.height / 2 + 40);
                this.ctx.textAlign = 'left';
            }
            
            stop() {
                this.gameRunning = false;
                document.removeEventListener('keydown', this.keyHandler);
            }
        }

        // Tetris Game Class - FIXED AND IMPROVED
        class TetrisGame {
            constructor(ctx, canvas) {
                this.ctx = ctx;
                this.canvas = canvas;
                this.gridSize = 20;
                this.cols = Math.floor(this.canvas.width / this.gridSize);
                this.rows = Math.floor(this.canvas.height / this.gridSize);
                this.board = Array(this.rows).fill().map(() => Array(this.cols).fill(0));
                this.currentPiece = this.generatePiece();
                this.score = 0;
                this.lines = 0;
                this.level = 1;
                this.gameRunning = true;
                this.lastTime = 0;
                this.dropTime = 0;
                this.dropInterval = 1000;
                
                console.log('Tetris game initialized');
                this.bindEvents();
                
                // Start the game loop
                requestAnimationFrame((time) => this.gameLoop(time));
            }
            
            generatePiece() {
                const pieces = [
                    { shape: [[1, 1, 1, 1]], color: '#00ffff' }, // I
                    { shape: [[1, 1], [1, 1]], color: '#ffff00' }, // O
                    { shape: [[0, 1, 0], [1, 1, 1]], color: '#800080' }, // T
                    { shape: [[1, 0, 0], [1, 1, 1]], color: '#ffa500' }, // L
                    { shape: [[0, 0, 1], [1, 1, 1]], color: '#0000ff' }, // J
                    { shape: [[0, 1, 1], [1, 1, 0]], color: '#00ff00' }, // S
                    { shape: [[1, 1, 0], [0, 1, 1]], color: '#ff0000' }  // Z
                ];
                
                const pieceData = pieces[Math.floor(Math.random() * pieces.length)];
                return {
                    shape: pieceData.shape,
                    color: pieceData.color,
                    x: Math.floor(this.cols / 2) - Math.floor(pieceData.shape[0].length / 2),
                    y: 0
                };
            }
            
            bindEvents() {
                this.keyHandler = (e) => {
                    if (!this.gameRunning) return;
                    
                    e.preventDefault();
                    switch (e.key) {
                        case 'ArrowLeft':
                        case 'a':
                        case 'A':
                            this.movePiece(-1, 0);
                            break;
                        case 'ArrowRight':
                        case 'd':
                        case 'D':
                            this.movePiece(1, 0);
                            break;
                        case 'ArrowDown':
                        case 's':
                        case 'S':
                            this.movePiece(0, 1);
                            break;
                        case 'ArrowUp':
                        case 'w':
                        case 'W':
                        case ' ':
                            this.rotatePiece();
                            break;
                    }
                };
                document.addEventListener('keydown', this.keyHandler);
            }
            
            movePiece(dx, dy) {
                const newX = this.currentPiece.x + dx;
                const newY = this.currentPiece.y + dy;
                
                if (this.isValidPosition(this.currentPiece.shape, newX, newY)) {
                    this.currentPiece.x = newX;
                    this.currentPiece.y = newY;
                    return true;
                }
                return false;
            }
            
            rotatePiece() {
                const rotated = this.currentPiece.shape[0].map((_, index) =>
                    this.currentPiece.shape.map(row => row[index]).reverse()
                );
                
                if (this.isValidPosition(rotated, this.currentPiece.x, this.currentPiece.y)) {
                    this.currentPiece.shape = rotated;
                }
            }
            
            isValidPosition(shape, x, y) {
                for (let row = 0; row < shape.length; row++) {
                    for (let col = 0; col < shape[row].length; col++) {
                        if (shape[row][col]) {
                            const newX = x + col;
                            const newY = y + row;
                            
                            if (newX < 0 || newX >= this.cols || newY >= this.rows || 
                                (newY >= 0 && this.board[newY][newX])) {
                                return false;
                            }
                        }
                    }
                }
                return true;
            }
            
            gameLoop(currentTime) {
                if (!this.gameRunning) return;
                
                const deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;
                this.dropTime += deltaTime;
                
                if (this.dropTime > this.dropInterval) {
                    if (!this.movePiece(0, 1)) {
                        this.placePiece();
                        this.clearLines();
                        this.currentPiece = this.generatePiece();
                        
                        if (!this.isValidPosition(this.currentPiece.shape, this.currentPiece.x, this.currentPiece.y)) {
                            this.gameOver();
                        }
                    }
                    this.dropTime = 0;
                }
                
                this.draw();
                requestAnimationFrame((time) => this.gameLoop(time));
            }
            
            placePiece() {
                for (let row = 0; row < this.currentPiece.shape.length; row++) {
                    for (let col = 0; col < this.currentPiece.shape[row].length; col++) {
                        if (this.currentPiece.shape[row][col]) {
                            const x = this.currentPiece.x + col;
                            const y = this.currentPiece.y + row;
                            if (y >= 0) {
                                this.board[y][x] = this.currentPiece.color;
                            }
                        }
                    }
                }
            }
            
            clearLines() {
                let linesCleared = 0;
                for (let row = this.rows - 1; row >= 0; row--) {
                    if (this.board[row].every(cell => cell !== 0)) {
                        this.board.splice(row, 1);
                        this.board.unshift(Array(this.cols).fill(0));
                        linesCleared++;
                        row++; // Check the same row again
                    }
                }
                
                if (linesCleared > 0) {
                    this.lines += linesCleared;
                    this.score += linesCleared * 100 * this.level;
                    this.level = Math.floor(this.lines / 10) + 1;
                    this.dropInterval = Math.max(100, 1000 - (this.level - 1) * 50);
                }
            }
            
            draw() {
                // Clear canvas
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw board
                for (let row = 0; row < this.rows; row++) {
                    for (let col = 0; col < this.cols; col++) {
                        if (this.board[row][col]) {
                            this.ctx.fillStyle = this.board[row][col];
                            this.ctx.fillRect(col * this.gridSize + 1, row * this.gridSize + 1, 
                                            this.gridSize - 2, this.gridSize - 2);
                        }
                    }
                }
                
                // Draw current piece
                this.ctx.fillStyle = this.currentPiece.color;
                for (let row = 0; row < this.currentPiece.shape.length; row++) {
                    for (let col = 0; col < this.currentPiece.shape[row].length; col++) {
                        if (this.currentPiece.shape[row][col]) {
                            const x = (this.currentPiece.x + col) * this.gridSize;
                            const y = (this.currentPiece.y + row) * this.gridSize;
                            this.ctx.fillRect(x + 1, y + 1, this.gridSize - 2, this.gridSize - 2);
                        }
                    }
                }
                
                // Draw grid lines
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 1;
                for (let i = 0; i <= this.cols; i++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(i * this.gridSize, 0);
                    this.ctx.lineTo(i * this.gridSize, this.canvas.height);
                    this.ctx.stroke();
                }
                for (let i = 0; i <= this.rows; i++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, i * this.gridSize);
                    this.ctx.lineTo(this.canvas.width, i * this.gridSize);
                    this.ctx.stroke();
                }
                
                // Draw UI
                this.ctx.fillStyle = '#fff';
                this.ctx.font = '14px Fira Code';
                this.ctx.fillText(`Score: ${this.score}`, 10, 25);
                this.ctx.fillText(`Lines: ${this.lines}`, 10, 45);
                this.ctx.fillText(`Level: ${this.level}`, 10, 65);
                this.ctx.fillText('WASD/Arrows: Move', 10, this.canvas.height - 60);
                this.ctx.fillText('W/Up/Space: Rotate', 10, this.canvas.height - 40);
                this.ctx.fillText('ESC: Exit', 10, this.canvas.height - 20);
            }
            
            gameOver() {
                this.gameRunning = false;
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.fillStyle = '#ff0080';
                this.ctx.font = '24px Fira Code';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Game Over!', this.canvas.width / 2, this.canvas.height / 2 - 30);
                this.ctx.fillText(`Score: ${this.score}`, this.canvas.width / 2, this.canvas.height / 2);
                this.ctx.fillText(`Lines: ${this.lines}`, this.canvas.width / 2, this.canvas.height / 2 + 30);
                this.ctx.fillText('Press ESC to close', this.canvas.width / 2, this.canvas.height / 2 + 60);
                this.ctx.textAlign = 'left';
            }
            
            stop() {
                this.gameRunning = false;
                document.removeEventListener('keydown', this.keyHandler);
            }
        }

        // Pong Game Class - FIXED AND IMPROVED
        class PongGame {
            constructor(ctx, canvas) {
                this.ctx = ctx;
                this.canvas = canvas;
                this.paddle1 = { x: 10, y: canvas.height / 2 - 50, width: 10, height: 100, speed: 6 };
                this.paddle2 = { x: canvas.width - 20, y: canvas.height / 2 - 50, width: 10, height: 100, speed: 6 };
                this.ball = { 
                    x: canvas.width / 2, 
                    y: canvas.height / 2, 
                    dx: 4 * (Math.random() > 0.5 ? 1 : -1), 
                    dy: 4 * (Math.random() > 0.5 ? 1 : -1), 
                    radius: 8,
                    speed: 4
                };
                this.score = { player1: 0, player2: 0 };
                this.gameRunning = true;
                this.keys = {};
                this.lastTime = 0;
                
                console.log('Pong game initialized');
                this.bindEvents();
                
                // Start the game loop
                requestAnimationFrame((time) => this.gameLoop(time));
            }
            
            bindEvents() {
                this.keyDownHandler = (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    e.preventDefault();
                };
                this.keyUpHandler = (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                    e.preventDefault();
                };
                
                document.addEventListener('keydown', this.keyDownHandler);
                document.addEventListener('keyup', this.keyUpHandler);
            }
            
            gameLoop(currentTime) {
                if (!this.gameRunning) return;
                
                const deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;
                
                this.update();
                this.draw();
                
                requestAnimationFrame((time) => this.gameLoop(time));
            }
            
            update() {
                // Move paddles
                if ((this.keys['arrowup'] || this.keys['w']) && this.paddle2.y > 0) {
                    this.paddle2.y -= this.paddle2.speed;
                }
                if ((this.keys['arrowdown'] || this.keys['s']) && this.paddle2.y < this.canvas.height - this.paddle2.height) {
                    this.paddle2.y += this.paddle2.speed;
                }
                
                // Simple AI for left paddle
                const paddleCenter = this.paddle1.y + this.paddle1.height / 2;
                if (paddleCenter < this.ball.y - 35) {
                    this.paddle1.y += this.paddle1.speed * 0.7;
                } else if (paddleCenter > this.ball.y + 35) {
                    this.paddle1.y -= this.paddle1.speed * 0.7;
                }
                
                // Keep paddles in bounds
                this.paddle1.y = Math.max(0, Math.min(this.canvas.height - this.paddle1.height, this.paddle1.y));
                this.paddle2.y = Math.max(0, Math.min(this.canvas.height - this.paddle2.height, this.paddle2.y));
                
                // Move ball
                this.ball.x += this.ball.dx;
                this.ball.y += this.ball.dy;
                
                // Ball collision with top/bottom
                if (this.ball.y <= this.ball.radius || this.ball.y >= this.canvas.height - this.ball.radius) {
                    this.ball.dy = -this.ball.dy;
                }
                
                // Ball collision with paddles
                if (this.ball.x - this.ball.radius <= this.paddle1.x + this.paddle1.width && 
                    this.ball.y >= this.paddle1.y - this.ball.radius && 
                    this.ball.y <= this.paddle1.y + this.paddle1.height + this.ball.radius &&
                    this.ball.dx < 0) {
                    this.ball.dx = -this.ball.dx;
                    this.ball.x = this.paddle1.x + this.paddle1.width + this.ball.radius;
                    
                    // Add some angle based on where ball hits paddle
                    const hitPos = (this.ball.y - (this.paddle1.y + this.paddle1.height / 2)) / (this.paddle1.height / 2);
                    this.ball.dy = hitPos * this.ball.speed;
                }
                
                if (this.ball.x + this.ball.radius >= this.paddle2.x && 
                    this.ball.y >= this.paddle2.y - this.ball.radius && 
                    this.ball.y <= this.paddle2.y + this.paddle2.height + this.ball.radius &&
                    this.ball.dx > 0) {
                    this.ball.dx = -this.ball.dx;
                    this.ball.x = this.paddle2.x - this.ball.radius;
                    
                    // Add some angle based on where ball hits paddle
                    const hitPos = (this.ball.y - (this.paddle2.y + this.paddle2.height / 2)) / (this.paddle2.height / 2);
                    this.ball.dy = hitPos * this.ball.speed;
                }
                
                // Score
                if (this.ball.x < 0) {
                    this.score.player2++;
                    this.resetBall();
                }
                if (this.ball.x > this.canvas.width) {
                    this.score.player1++;
                    this.resetBall();
                }
                
                // Check win condition
                if (this.score.player1 >= 5 || this.score.player2 >= 5) {
                    this.gameOver();
                }
            }
            
            resetBall() {
                this.ball.x = this.canvas.width / 2;
                this.ball.y = this.canvas.height / 2;
                this.ball.dx = this.ball.speed * (Math.random() > 0.5 ? 1 : -1);
                this.ball.dy = this.ball.speed * (Math.random() > 0.5 ? 1 : -1);
            }
            
            draw() {
                // Clear canvas
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw center line
                this.ctx.setLineDash([5, 15]);
                this.ctx.beginPath();
                this.ctx.moveTo(this.canvas.width / 2, 0);
                this.ctx.lineTo(this.canvas.width / 2, this.canvas.height);
                this.ctx.strokeStyle = '#333';
                this.ctx.stroke();
                this.ctx.setLineDash([]);
                
                // Draw paddles
                this.ctx.fillStyle = '#00ff41';
                this.ctx.fillRect(this.paddle1.x, this.paddle1.y, this.paddle1.width, this.paddle1.height);
                this.ctx.fillRect(this.paddle2.x, this.paddle2.y, this.paddle2.width, this.paddle2.height);
                
                // Draw ball
                this.ctx.fillStyle = '#ff0080';
                this.ctx.beginPath();
                this.ctx.arc(this.ball.x, this.ball.y, this.ball.radius, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Draw score
                this.ctx.fillStyle = '#fff';
                this.ctx.font = '32px Fira Code';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(this.score.player1, this.canvas.width / 4, 60);
                this.ctx.fillText(this.score.player2, 3 * this.canvas.width / 4, 60);
                
                // Draw instructions
                this.ctx.font = '12px Fira Code';
                this.ctx.fillText('CPU vs Player', this.canvas.width / 2, this.canvas.height - 60);
                this.ctx.fillText('Player: W/S or ↑/↓', this.canvas.width / 2, this.canvas.height - 40);
                this.ctx.fillText('First to 5 wins! Press ESC to exit', this.canvas.width / 2, this.canvas.height - 20);
                this.ctx.textAlign = 'left';
            }
            
            gameOver() {
                this.gameRunning = false;
                const winner = this.score.player1 >= 5 ? 'CPU' : 'Player';
                
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.fillStyle = '#ff0080';
                this.ctx.font = '24px Fira Code';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(`${winner} Wins!`, this.canvas.width / 2, this.canvas.height / 2 - 20);
                this.ctx.fillText(`Final Score: ${this.score.player1} - ${this.score.player2}`, this.canvas.width / 2, this.canvas.height / 2 + 10);
                this.ctx.fillText('Press ESC to close', this.canvas.width / 2, this.canvas.height / 2 + 40);
                this.ctx.textAlign = 'left';
            }
            
            stop() {
                this.gameRunning = false;
                document.removeEventListener('keydown', this.keyDownHandler);
                document.removeEventListener('keyup', this.keyUpHandler);
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            new NeonOracle();
        });
    </script>
</body>
</html>
